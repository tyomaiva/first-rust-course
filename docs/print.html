<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Course</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="rustviz_plugin/visualization.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Basics of Rust</li><li class="chapter-item expanded "><a href="setting_up.html"><strong aria-hidden="true">2.</strong> Setup</a></li><li class="chapter-item expanded "><a href="syntax_basics.html"><strong aria-hidden="true">3.</strong> Syntax basics</a></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">4.</strong> Ownership and borrow checker</a></li><li class="chapter-item expanded "><a href="traits_generics.html"><strong aria-hidden="true">5.</strong> Traits and generics</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">6.</strong> Enums</a></li><li class="chapter-item expanded affix "><li class="part-title">Embedded Rust</li><li class="chapter-item expanded "><a href="embedded_introduction.html"><strong aria-hidden="true">7.</strong> What makes Embedded Rust special</a></li><li class="chapter-item expanded "><a href="hello_embedded_world.html"><strong aria-hidden="true">8.</strong> Hello, Embedded world!</a></li><li class="chapter-item expanded "><a href="microbit_introduction.html"><strong aria-hidden="true">9.</strong> What is Micro:bit?</a></li><li class="chapter-item expanded "><a href="blink.html"><strong aria-hidden="true">10.</strong> The LED matrix</a></li><li class="chapter-item expanded "><a href="serial.html"><strong aria-hidden="true">11.</strong> Serial communication with UART</a></li><li class="chapter-item expanded "><a href="accelerometer_streaming.html"><strong aria-hidden="true">12.</strong> Putting all together: streaming data from the accelerometer</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to a course for the Rust programming language!</p>
<p>The goals of the course:</p>
<ul>
<li>Learn to write basic Rust code and read API docs like <a href="https://doc.rust-lang.org/core/option/enum.Option.html">this</a></li>
<li>Get experience with Embedded Rust on a real hardware platform</li>
</ul>
<p><em>Out</em> of scope:</p>
<ul>
<li>Motivation to learn Rust (we tried to accomplish that in the previous sessions)</li>
<li>Data collections like <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a> or <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html">HashMap</a>, since they involve heap allocation, which is often undesirable in embedded systems. In general, we omit the Rust standard library completely</li>
<li>Multithreading and asynchronous programming, though both are quite easy with Embedded Rust (see <a href="https://embassy.dev/">here</a> and <a href="https://rtic.rs/1/book/en/">here</a>), and almost unavoidable when implementing an RTOS</li>
<li>Unit testing, modularization, and other good development practices, since all of our projects will be very small</li>
</ul>
<!-- + Smart pointers like [Box](https://doc.rust-lang.org/std/boxed/struct.Box.html), for the same reason -->
<!-- What knowledge is expected: -->
<!-- + how stack/heap works -->
<!-- + UNIX shell (e.g. bash) ?????????? -->
<!-- + C++ experience is useful, as we will draw analogies and make comparisons from time to time -->
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li>The official <a href="https://doc.rust-lang.org/book/">Rust book</a> is written extremely clear and is quite comprehensive. Absolute recommendation if you are serious about Rust!</li>
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a> is a nice crash course without much theory. Note: it may actually take more than 30 minutes to read and digest.</li>
<li><a href="https://docs.rust-embedded.org/discovery/microbit/">The Discovery book</a> is an introductory resource on Embedded Rust using the same hardware platform that we cover here</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<blockquote>
<p><em>Note</em>: this Section is optional for the first part of the course. You need it only whenever you want to run the code examples <em>locally</em> on your system. Otherwise, use the online sandbox <a href="https://play.rust-lang.org/">Rust Playground</a>.
However, for the embedded part, this Section is mandatory, since we want to interface our physical microcontroller boards.</p>
</blockquote>
<h2 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting up the environment</a></h2>
<p>If something below goes wrong, go for more details to <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">https://doc.rust-lang.org/book/ch01-01-installation.html</a></p>
<h3 id="installing-rust-on-windows"><a class="header" href="#installing-rust-on-windows">Installing Rust on Windows</a></h3>
<p>Before installing Rust, it also requires the C++ build tools. In case you do not have those, you can get them via this link: <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">https://visualstudio.microsoft.com/visual-cpp-build-tools/</a></p>
<p>To install Rust itself, go to the following link and follow the instructions for installation: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>
<h3 id="installing-rust-on-linux-or-macos"><a class="header" href="#installing-rust-on-linux-or-macos">Installing Rust on Linux or macOS</a></h3>
<p>The following command downloads and installs the latest stable version of Rust:</p>
<pre><code class="language-shell">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Rust also needs a C linker. In case you do not have one, do the following:</p>
<ul>
<li>For <strong>Linux</strong></li>
</ul>
<pre><code class="language-shell">sudo apt-get update
sudo apt install build-essential
</code></pre>
<ul>
<li>For <strong>macOS</strong></li>
</ul>
<pre><code class="language-shell">xcode-select install
</code></pre>
<h3 id="what-ides-can-be-used"><a class="header" href="#what-ides-can-be-used">What IDEs can be used?</a></h3>
<p>Mainly for syntax highlighting, code completion, etc. Both have Rust plugins:</p>
<ul>
<li>Visual Studio Code (<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a>)</li>
<li>IntelliJ IDEA</li>
</ul>
<h2 id="setting-up-a-basic-project"><a class="header" href="#setting-up-a-basic-project">Setting up a basic project</a></h2>
<p>It's easy to generate a new Rust project template using the <code>cargo</code> command (it is bundled automatically with Rust), by running the following in your shell:</p>
<pre><code class="language-shell">cargo new my_rust_sandbox
cd my_rust_sandbox
</code></pre>
<p>Inside the new directory,</p>
<ul>
<li><em>src</em> sub-directory is generated with a file inside called <em>main.rs</em> which contains a &quot;Hello World!&quot; program. In order to run examples from the next Sections, just copy the code from an example and replace the contents of this file with that.</li>
<li><em>Cargo.toml</em> file is generated which basically configures your program. We don't need any external dependencies for the first part of the course, so this file can be kept untouched.</li>
</ul>
<p>To (re-)build and run the executable, use</p>
<pre><code class="language-shell">cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-basics"><a class="header" href="#syntax-basics">Syntax basics</a></h1>
<!-- + `use` creates shorthand aliases, so instead of typing `std::io::stdin()` we type `io::stdin()` -->
<h2 id="first-code-snippet"><a class="header" href="#first-code-snippet">First code snippet</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut index = 10; // Define a variable
    while index != 0 {
        println!(&quot;Counting down: {}&quot;, index);
        /* Decrease the value on each iteration */
        index -= 1;
    }
}
</code></pre></pre>
<p>Several things to note here:</p>
<ul>
<li><code>fn</code> defines a new function, in this case it is called <code>main</code>, it does not have any input arguments and does not return anything either</li>
<li><code>let mut</code> binds a value <code>10</code> to a <em>mutable</em> variable called <code>index</code>
<ul>
<li>If you omit <code>mut</code>, you get instead an <em>immutable</em> variable, which does not work in this case, try it!</li>
<li>So variables in Rust are immutable by default</li>
</ul>
</li>
<li>Syntax is similar to C and languages that (partially) inherited the C syntax (like C++, Java, and JavaScript): brackets, braces, semicolons, comparison and increment/decrement operators, comments</li>
<li><code>println!()</code> does formatted printing, similar to <code>printf()</code> in C, but more powerful</li>
<li>You can edit this code snippet and re-run it without leaving this webpage. Alternatively, you can copy it and run in the <a href="https://play.rust-lang.org/">Rust Playground</a></li>
</ul>
<h2 id="basic-built-in-types"><a class="header" href="#basic-built-in-types">Basic built-in types</a></h2>
<p>In the example above, the type of the variable <code>index</code> is inferred automatically</p>
<ul>
<li>In that case it is <code>i32</code>, which is a 32-bit signed integer</li>
<li>You can get this information by hovering over <code>index</code> in your IDE with Rust Language Server enabled (e.g. in Visual Studio Code)</li>
<li>If we change <code>10</code> to <code>10.</code>, we get instead the double-precision floating-point type, <code>f64</code></li>
<li>If you want to use a different type, you need to specify it explicitly</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let index: u8 = 10;
    // OR
    let index = 10_u8;
    // OR
    let index = 10 as u8;
}
</code></pre></pre>
<ul>
<li><code>u8</code> is 8-bit unsigned integer type, which is very popular in Embedded Rust and in general in low-level programming, where we have to shuffle individual bytes</li>
<li><code>usize</code> is another extremely popular type, which is an unsigned integer with native size (32-bit for 32-bit architectures like ARM Cortex-M, 64-bit for a desktop/laptop CPU)</li>
<li><code>bool</code> is a type with two possible values: <code>true</code> and <code>false</code></li>
<li>More types here: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#scalar-types">Scalar Types</a></li>
</ul>
<h2 id="user-defined-types"><a class="header" href="#user-defined-types">User-defined types</a></h2>
<p>Apart from the basic types, we often want to combine them in a <em>compound</em> user-defined type</p>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<!-- tuples go before arrays as an example for the latter needs an iterator that produces a tuple -->
<p>A tuple combines values of different types</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let tuple = (&quot;Something&quot;, 2);
    println!(&quot;{}, {}&quot;, tuple.0, tuple.1);
<span class="boring">}
</span></code></pre></pre>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Structs are similar to tuples in that they combine potentially different types, but each field is <em>named</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyPoint {
    x: f64,
    y: f64,
}

    let point = MyPoint{x: 3., y: 4.};
    println!(&quot;The point is: (x: {}, y: {})&quot;, point.x, point.y);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Note that if you pass <code>{x: 3, y: 4}</code> instead of <code>{x: 3., y:4.}</code>, you get a compiler error (try it!): you need to convert the types explicitly, e.g. <code>{x: 3 as f64, y: 4 as f64)</code> will do the trick. It is a safety feature, to avoid accidental type castings</li>
</ul>
<p>You can associate methods acting on a given struct type (encapsulation):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span>impl MyPoint {
    fn new(x: f64, y: f64) -&gt; Self {
        Self{x: x, y: y}
    }

    fn is_close_to_origin(self) -&gt; bool {
        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
    }
}

fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<ul>
<li>Implementing <code>new()</code> is a customary way of initializing structs. It's like a class constructor in C++, with two major differences:
<ul>
<li>Call of <code>new()</code> should be always <em>explicit</em> (no implicit construction)</li>
<li>There can be only one implementation of <code>new()</code>, since Rust intentionally does not have function overloading. If you need multiple ways to construct an object (e.g. construct a default struct value and a custom one), use the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">Builder pattern</a> instead</li>
</ul>
</li>
<li><code>Self</code> is an alias to the current struct <em>type</em>, so <code>Self</code> \( \iff \) <code>MyPoint</code></li>
<li><code>self</code> is an alias to the current struct <em>instance</em>, so <code>self</code> \( \iff \) <code>point</code></li>
</ul>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Array is a fixed-size collection of elements of the <em>same</em> type (similar to C arrays)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut array = [7, 21, 42];
    array[0] += 20;
    println!(&quot;{:?}&quot;, array);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Note the <code>{:?}</code> syntax which normally tells to dump the contents of the variable. We will elaborate on this <a href="./traits.html">later</a>, while discussing the <code>Debug</code> trait.</li>
</ul>
<p>What happens if we access an index out of range?</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [7, 21, 42];
    let mut index = 0;
    loop {
        println!(&quot;The element #{} is {}&quot;, index, array[index]);
        index += 1;
    }
}
</code></pre></pre>
<ul>
<li>It is safe to do (i.e., no undefined behaviour), the Rust program just panics and writes a diagnostic post-mortem message</li>
<li><code>loop</code> denotes an infinite loop (a dedicated language construct, unlike the hacky <code>while(1)</code> and <code>for(;;)</code> in C)</li>
</ul>
<p>More idiomatic (and less error-prone) alternative is to use Rust <em>iterators</em></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [7, 21, 42];
    for (index, element) in array.iter().enumerate() {
        println!(&quot;The element #{} is {}&quot;, index, element);
    }
}
</code></pre></pre>
<p>Nested arrays</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let light_pattern = [
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 0, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
    ];
    println!(&quot;{}&quot;, light_pattern[0][0]);
    println!(&quot;{}&quot;, light_pattern[2][2]);
<span class="boring">}
</span></code></pre></pre>
<p>We will use this code for blinking a 5x5 LED matrix in the <a href="./blink.html">Embedded Rust part</a></p>
<blockquote>
<h4 id="exercise"><a class="header" href="#exercise">Exercise</a></h4>
<p>Implement a 2D straight-line type <code>Line</code></p>
<ul>
<li><code>Line</code> can be constructed by supplying two endpoints</li>
<li><code>Line</code> has a method <code>is_point_on_line()</code> which checks whether a given point belongs to the line or not</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64
</span><span class="boring">}
</span><span class="boring">impl MyPoint {
</span><span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">}
</span>fn main() {
    let point1 = MyPoint::new(2., 1.);
    let point2 = MyPoint::new(-2., -1.);
    let segment1 = Line::new(point1, point2);
    let point3 = MyPoint::new(4., 2.);
    assert_eq!(segment1.is_point_on_line(point3), true);
    // let point4 = MyPoint::new(1., 1.);
    // assert_eq!(segment2.is_point_on_line(point4), false);
}
</code></pre></pre>
<!-- struct Line(MyPoint, MyPoint); -->
<!-- impl Line { -->
<!--     fn new(point1: MyPoint, point2: MyPoint) -> Self { -->
<!--         Self(point1, point2) -->
<!--     } -->
<!--     fn is_point_on_line(self, point: MyPoint) -> bool { -->
<!--         let vector1 = MyPoint::new(self.0.x - self.1.x, self.0.y - self.1.y); -->
<!--         let vector2 = MyPoint::new(point.x - self.1.x, point.y - self.1.y); -->
<!--         (vector1.x * vector2.y - vector1.y * vector2.x).abs() < 10. * f64::EPSILON -->
<!--     } -->
<!-- } -->
<blockquote>
<p>(*) Implement a type <code>Triangle</code> (you may choose between 2D and 3D triangles)</p>
<ul>
<li><code>Triangle</code> can be constructed based on three vertices</li>
<li><code>Triangle</code> has a method to check whether a given point lies within it or not</li>
</ul>
</blockquote>
<h2 id="resources-for-deeper-understanding"><a class="header" href="#resources-for-deeper-understanding">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html">Chapter 3</a>, <a href="https://doc.rust-lang.org/book/ch05-00-structs.html">Chapter 5</a> and <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">here</a> in the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrow-checker"><a class="header" href="#ownership-and-borrow-checker">Ownership and borrow checker</a></h1>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<ul>
<li>Case with fn length(self) -&gt; f64 : move occurs, the number is not usable anymore</li>
</ul>
<h2 id="warm-up-example"><a class="header" href="#warm-up-example">Warm up example</a></h2>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>The ownership and access system in Rust is quite restrictive and also non-intuitive at first for developers with C++/Java/C# background. As we will see, the reason is to guarantee safety, at compile time. In this Section, we will use the <a href="https://github.com/rustviz/rustviz">RustViz</a> tool to visualize these challenging concepts.</p>
<p>Here are the basic rules:</p>
<ul>
<li>Objects in Rust have only <em>one</em> owner at a time, meaning there is <em>one and only one</em> responsible for deallocating the object when it's not needed anymore.
<ul>
<li>No memory leaks or <a href="https://stackoverflow.com/a/21057524">double frees</a> anymore</li>
<li>Owner can change over time by <em>moving</em> the object, but at any given time there is only one owner</li>
</ul>
</li>
<li>Deallocation is similar to RAII in C++: the object is droppped when the last owner goes out of scope</li>
<li>All the potential code locations for deallocation can be determined at compile-time, so no need for garbage collection (unlike Java and C#)</li>
</ul>
<h2 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow checker</a></h2>
<ul>
<li>You can access an object without owning it. You are then <em>borrowing</em> it, which basically means you have a reference (or a pointer, if we dig at lower level) to an object</li>
<li>Either you only read the object contents (<em>immutable borrow</em>) or both read and write (<em>mutable borrow</em>)</li>
<li>You can have <em>multiple immutable</em> borrows OR a <em>single mutable</em> borrow (not both at the same time)
<ul>
<li>Immutable borrow means not only that you can't change the object, but nobody else can do that either!</li>
</ul>
</li>
<li>By default, objects are moved, not copied, when assigned or passed as function arguments (in contrast with C++)
<ul>
<li>No implicit copies apart from some basic types (like <code>u8</code>) and special user-defined types (we will cover it in <a href="./traits_generics.html">the traits Section</a>)</li>
</ul>
</li>
</ul>
<div class="flex-container vis_block" style="position:relative; margin-left:-75px; margin-right:-75px; display">
    <object type="image/svg+xml" class="copy code_panel" data="rustviz_assets/example1/vis_code.svg"></object>
    <object type="image/svg+xml" class="copy tl_panel" data="rustviz_assets/example1/vis_timeline.svg" style="width: auto;" onmouseenter="helpers('copy')"></object>
</div>
<h2 id="resources-for-deeper-understanding-1"><a class="header" href="#resources-for-deeper-understanding-1">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Chapter 4</a> of the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-and-generics"><a class="header" href="#traits-and-generics">Traits and generics</a></h1>
<h2 id="todo-1"><a class="header" href="#todo-1">TODO</a></h2>
<ul>
<li>Good for dependency injection and mocking while testing</li>
<li>Some objects can be neither copied nor cloned (makes sense for a unique resource like an open file)</li>
</ul>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Real-world trait: <a href="https://doc.rust-lang.org/core/fmt/trait.Write.html">core::fmt::Write</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Write {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; Result;

    fn write_char(&amp;mut self, c: char) -&gt; Result { ... }
    fn write_fmt(&amp;mut self, args: Arguments&lt;'_&gt;) -&gt; Result { ... }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>This trait is normally used for unbuffered writes (like appending characters to a string)</li>
<li>Good thing: you only need to implement <code>write_str()</code>, the other two methods are provided automatically</li>
<li>Allows to use <code>println!</code>-like formatted printing</li>
</ul>
<pre><code class="language-rust noplayground">    // w implements core::fmt::Write
    // ...
    write!(w, &quot;Formatted {}&quot;, &quot;printing&quot;).unwrap();
</code></pre>
<ul>
<li>We will use this feature later for <a href="./serial.html">serial communication</a></li>
</ul>
<blockquote>
<h4 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h4>
<p>Implement a struct that implements <code>core::fmt::Write</code>, so that writing to that struct does several things:</p>
<ul>
<li>The message contents is printed on screen</li>
<li>An internal statistical counter is updated (side effect). The counter keeps track of total number of characters being ever written</li>
<li>(*) Every second time you write to the struct, the counter value is printed on screen</li>
<li>(**) You print only whenever end-of-line is encountered in your message, but buffer the message otherwise (similar to <code>printf()</code> in C). Yes, <code>core::fmt::Write</code> is used for <em>unbuffered</em> writes, so such an implementation is not recommended for production use :-)</li>
</ul>
</blockquote>
<h2 id="resources-for-deeper-understanding-2"><a class="header" href="#resources-for-deeper-understanding-2">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Chapter 10</a> of the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<h2 id="todo-2"><a class="header" href="#todo-2">TODO</a></h2>
<ul>
<li>Pattern matching</li>
</ul>
<p>Whenever an operation may return either some value or <em>no value at all</em>, it is idiomatic to use <a href="https://doc.rust-lang.org/core/option/enum.Option.html"><code>core::option::Option</code></a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>Option</code> is similar to C++ <code>std::optional</code>, which was introduced only in C++17</li>
</ul>
<p><code>Option</code> has many batteries included:</p>
<ul>
<li><code>#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]</code></li>
<li>Plenty of functions</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: Option&lt;u8&gt; = Some(2);
    assert_eq!(x.is_some(), true);
    assert_eq!(x.unwrap(), 2);
    assert_eq!(x.expect(&quot;Oops!&quot;), 2);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: Option&lt;u8&gt; = None;
    x.expect(&quot;Oops!&quot;);
}
</code></pre></pre>
<p>Whenever an operation may <em>fail</em>, it is idiomatic to use <a href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>core::result::Result</code></a> instead</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>It has a set of batteries very similar to <code>Option</code></li>
<li>If a function returns a <code>Result</code> and the caller ignores the returned value, the compiler gives a warning</li>
<li>It is very popular to use the <code>?</code> syntactic sugar to propagate errors in an elegant way:</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn problematic_function() -&gt; Result&lt;u8, ()&gt; {
    let x: Result&lt;u8, ()&gt; = Err(());
    println!(&quot;{:?}&quot;, x?);
    Ok(4)
}

fn main() {
    println!(&quot;{:?}&quot;, problematic_function());
}
</code></pre></pre>
<ul>
<li>Compare this approach with C++/Java/Python exceptions, where error propagation is <em>non-local</em> and you may easily get an exception at runtime that you were not even aware of and which crashes the application! (Or even worse, bloat the code with catching all potential exceptions in a paranoic fashion, just to be on the safe side.)</li>
</ul>
<h2 id="resources-for-deeper-understanding-3"><a class="header" href="#resources-for-deeper-understanding-3">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Chapter 6</a>, <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">also here</a> and <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">here</a> in the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-makes-embedded-rust-special"><a class="header" href="#what-makes-embedded-rust-special">What makes Embedded Rust special</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-embedded-world"><a class="header" href="#hello-embedded-world">Hello, Embedded world!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-microbit"><a class="header" href="#what-is-microbit">What is Micro:bit?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-led-matrix"><a class="header" href="#the-led-matrix">The LED matrix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serial-communication-with-uart"><a class="header" href="#serial-communication-with-uart">Serial communication with UART</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="putting-all-together-streaming-data-from-the-accelerometer"><a class="header" href="#putting-all-together-streaming-data-from-the-accelerometer">Putting all together: streaming data from the accelerometer</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="rustviz_plugin/helpers.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
