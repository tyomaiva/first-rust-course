<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Course</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="rustviz_plugin/visualization.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Basics of Rust</li><li class="chapter-item expanded "><a href="setting_up.html"><strong aria-hidden="true">2.</strong> Setup</a></li><li class="chapter-item expanded "><a href="syntax_basics.html"><strong aria-hidden="true">3.</strong> Syntax basics</a></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">4.</strong> Ownership and borrow checker</a></li><li class="chapter-item expanded "><a href="traits_generics.html"><strong aria-hidden="true">5.</strong> Traits and generics</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">6.</strong> Enums</a></li><li class="chapter-item expanded affix "><li class="part-title">Embedded Rust</li><li class="chapter-item expanded "><a href="embedded_introduction.html"><strong aria-hidden="true">7.</strong> What makes Embedded Rust special</a></li><li class="chapter-item expanded "><a href="hello_embedded_world.html"><strong aria-hidden="true">8.</strong> Hello, Embedded world!</a></li><li class="chapter-item expanded "><a href="microbit_introduction.html"><strong aria-hidden="true">9.</strong> What is Micro:bit?</a></li><li class="chapter-item expanded "><a href="blink.html"><strong aria-hidden="true">10.</strong> The LED matrix</a></li><li class="chapter-item expanded "><a href="serial.html"><strong aria-hidden="true">11.</strong> Serial communication with UART</a></li><li class="chapter-item expanded "><a href="accelerometer_streaming.html"><strong aria-hidden="true">12.</strong> Putting all together: streaming data from the accelerometer</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to a Rust programming language course!</p>
<p>The goals of the course:</p>
<ul>
<li>Learn to write basic Rust code and read API docs like <a href="https://doc.rust-lang.org/core/option/enum.Option.html">this</a></li>
<li>Get experience with Embedded Rust on a real hardware platform</li>
</ul>
<p><em>Out</em> of scope:</p>
<ul>
<li>Motivation to learn Rust (we tried to accomplish that in the previous sessions)</li>
<li>Data collections like <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a> or <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html">HashMap</a>, since they involve heap allocation, which is often undesirable in embedded systems. Also no file access and no other forms of I/O (printing to standard output is the only exception). In general, we omit the Rust standard library.</li>
<li>Multithreading and asynchronous programming, though both are quite easy with Embedded Rust (see <a href="https://embassy.dev/">here</a> and <a href="https://rtic.rs/1/book/en/">here</a>), and almost unavoidable when implementing an RTOS</li>
<li>Unit testing, modularization, and other good development practices, since all of our projects will be very small</li>
<li>PAC layer of Embedded Rust. We start directly with the higher abstraction levels which are HAL and BSP. So no direct register manipulation.</li>
</ul>
<!-- + Smart pointers like [Box](https://doc.rust-lang.org/std/boxed/struct.Box.html), for the same reason -->
<!-- What knowledge is expected: -->
<!-- + how stack/heap works -->
<!-- + UNIX shell (e.g. bash) ?????????? -->
<!-- + C++ experience is useful, as we will draw analogies and make comparisons from time to time -->
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a> is a nice crash course without much theory. Note: it may actually take more than 30 minutes to read and digest ðŸ˜Š</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/">Teaching material</a> developed by Ferrous Systems, a company which specializes in Rust development (including Embedded Rust) and in providing Rust trainings</li>
<li>The official <a href="https://doc.rust-lang.org/book/">Rust book</a> is written extremely clear and is quite comprehensive. Absolute recommendation if you are serious about Rust!</li>
<li><a href="https://docs.rust-embedded.org/discovery/microbit/">The Discovery book</a> is an introductory resource on Embedded Rust using the same hardware platform that we cover here</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<blockquote>
<p><em>Note</em>: this Section is optional for the first part of the course. You need it only whenever you want to run the code examples <em>locally</em> on your system. Otherwise, use the online sandbox <a href="https://play.rust-lang.org/">Rust Playground</a>.
However, for the embedded part, this Section is mandatory, since we want to interface our physical microcontroller boards.</p>
</blockquote>
<h2 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting up the environment</a></h2>
<p>If something below goes wrong, go for more details to <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">https://doc.rust-lang.org/book/ch01-01-installation.html</a></p>
<h3 id="installing-rust-on-windows"><a class="header" href="#installing-rust-on-windows">Installing Rust on Windows</a></h3>
<p>Before installing Rust, it also requires the C++ build tools. In case you do not have those, you can get them via this link: <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">https://visualstudio.microsoft.com/visual-cpp-build-tools/</a></p>
<p>To install Rust itself, go to the following link and follow the instructions for installation: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>
<h3 id="installing-rust-on-linux-or-macos"><a class="header" href="#installing-rust-on-linux-or-macos">Installing Rust on Linux or macOS</a></h3>
<p>The following command downloads and installs the latest stable version of Rust:</p>
<pre><code class="language-shell">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Rust also needs a C linker. In case you do not have one, do the following:</p>
<ul>
<li>For <strong>Linux</strong></li>
</ul>
<pre><code class="language-shell">sudo apt-get update
sudo apt install build-essential
</code></pre>
<ul>
<li>For <strong>macOS</strong></li>
</ul>
<pre><code class="language-shell">xcode-select install
</code></pre>
<h3 id="what-ides-can-be-used"><a class="header" href="#what-ides-can-be-used">What IDEs can be used?</a></h3>
<p>Mainly for syntax highlighting, code completion, etc. Both have Rust plugins:</p>
<ul>
<li>Visual Studio Code (<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a>)</li>
<li>IntelliJ IDEA</li>
</ul>
<h2 id="setting-up-a-basic-project"><a class="header" href="#setting-up-a-basic-project">Setting up a basic project</a></h2>
<p>We will use Cargo, which comes with the Rust installation. What does it do?</p>
<ul>
<li>Package manager (e.g., it fetches and builds external dependencies)</li>
<li>Build system (it compiles your packages)</li>
</ul>
<p>Cargo can be used to generate a new Rust project template, by running the following in your shell:</p>
<pre><code class="language-shell">cargo new my_rust_sandbox
cd my_rust_sandbox
</code></pre>
<p>Inside the new directory,</p>
<ul>
<li><em>src</em> sub-directory is generated with a file inside called <em>main.rs</em> which contains a &quot;Hello World!&quot; program. In order to run examples from the next Sections, just copy the code from an example and replace the contents of this file with that.</li>
<li><em>Cargo.toml</em> file is generated which basically configures your program. We don't need any external dependencies for the first part of the course, so this file can be kept untouched.</li>
</ul>
<p>To (re-)build and run the executable, use</p>
<pre><code class="language-shell">cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-basics"><a class="header" href="#syntax-basics">Syntax basics</a></h1>
<!-- + `use` creates shorthand aliases, so instead of typing `std::io::stdin()` we type `io::stdin()` -->
<h2 id="first-code-snippet"><a class="header" href="#first-code-snippet">First code snippet</a></h2>
<blockquote>
<p>You can edit and run most of the code snippets on this page without leaving your browser. Alternatively, you can copy them to the <a href="https://play.rust-lang.org/">Rust Playground</a> and run there</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut index = 10; // Define a variable
    while index != 0 {
        println!(&quot;Counting down: {}&quot;, index);
        /* Decrease the value on each iteration */
        index -= 1;
    }
}
</code></pre></pre>
<p>Several things to note here:</p>
<ul>
<li><code>fn</code> defines a new function, in this case it is called <code>main</code>, it does not have any input arguments and does not return anything either. <code>main()</code> is the entry point of the program.</li>
<li><code>let mut</code> binds a value <code>10</code> to a <em>mutable</em> variable called <code>index</code>
<ul>
<li>If you omit <code>mut</code>, you get instead an <em>immutable</em> variable, which does not work in this case, try it!</li>
<li>So variables in Rust are immutable by default</li>
</ul>
</li>
<li>Syntax is similar to C and languages that (partially) inherited the C syntax (like C++, Java, and JavaScript): brackets, braces, semicolons, comparison and increment/decrement operators, comments</li>
<li><code>println!()</code> does formatted printing, similar to <code>printf()</code> in C, but more powerful</li>
</ul>
<h2 id="basic-built-in-types"><a class="header" href="#basic-built-in-types">Basic built-in types</a></h2>
<p>In the example above, the type of the variable <code>index</code> is inferred automatically</p>
<ul>
<li>In that case it is <code>i32</code>, which is a 32-bit signed integer</li>
<li>You can get this information by hovering over <code>index</code> in your IDE with Rust Language Server enabled (e.g. in Visual Studio Code)</li>
<li>If we change <code>10</code> to <code>10.</code>, we get instead the double-precision floating-point type, <code>f64</code></li>
<li>If you want to use a different type, you need to specify it explicitly</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let index: u8 = 10;
    // OR
    let index = 10_u8;
    // OR
    let index = 10 as u8;
}
</code></pre></pre>
<ul>
<li><code>u8</code> is 8-bit unsigned integer type, which is very popular in Embedded Rust and in general in low-level programming, where we have to shuffle individual bytes</li>
<li><code>usize</code> is another extremely popular type, which is an unsigned integer with native size (32-bit for 32-bit architectures like ARM Cortex-M, 64-bit for a desktop/laptop CPU)</li>
<li><code>bool</code> is a type with two possible values: <code>true</code> and <code>false</code></li>
<li>More types here: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#scalar-types">Scalar Types</a></li>
</ul>
<h2 id="user-defined-types"><a class="header" href="#user-defined-types">User-defined types</a></h2>
<p>Apart from the basic types, we often want to combine them in a <em>compound</em> user-defined type</p>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<!-- tuples go before arrays as an example for the latter needs an iterator that produces a tuple -->
<p>A tuple combines values of different types</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let tuple = (&quot;Something&quot;, 2);
    println!(&quot;The tuple contents are: {}, {}&quot;, tuple.0, tuple.1);
}
</code></pre></pre>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Structs are similar to tuples in that they combine potentially different types, but each field is <em>named</em> and the struct type itself has a name:</p>
<pre><pre class="playground"><code class="language-rust editable">struct MyPoint {
    x: f64,
    y: f64,
}
fn main() {
    let point = MyPoint{x: 3., y: 4.};
    println!(&quot;The point coordinates are: x: {}, y: {}&quot;, point.x, point.y);
}
</code></pre></pre>
<ul>
<li>Note that if you pass <code>{x: 3, y: 4}</code> instead of <code>{x: 3., y:4.}</code>, you get a compiler error (try it!): you need to convert the types explicitly, e.g. <code>{x: 3 as f64, y: 4 as f64)</code> will do the trick. It is a safety feature, to avoid accidental type castings</li>
</ul>
<p>You can associate methods with the struct type (encapsulation):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span>impl MyPoint {
    fn new(x: f64, y: f64) -&gt; Self {
        Self{x: x, y: y}
    }

    fn is_close_to_origin(self) -&gt; bool {
        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
    }
}

fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<ul>
<li>Implementing <code>new()</code> is a customary way of initializing structs. It's like a class constructor in C++, with two major differences:
<ul>
<li>Call of <code>new()</code> should be always <em>explicit</em> (no implicit construction)</li>
<li>There can be only one implementation of <code>new()</code>, since Rust intentionally does not have function overloading. If you need multiple ways to construct an object (e.g. construct a default struct value and a custom one), use the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">Builder pattern</a> instead</li>
</ul>
</li>
<li><code>Self</code> is an alias to the current struct <em>type</em>, so <code>Self</code> \( \iff \) <code>MyPoint</code></li>
<li><code>self</code> is an alias to the current struct <em>instance</em>, so <code>self</code> \( \iff \) <code>point</code></li>
<li><a href="https://doc.rust-lang.org/beta/core/macro.assert_eq.html"><code>assert_eq!(a, b)</code></a> checks if <code>a == b</code>, if not, it panics (i.e., the whole process is shut down in a safe way and a diagnostic post-mortem message gets written).</li>
</ul>
<blockquote>
<h4 id="exercise"><a class="header" href="#exercise">Exercise</a></h4>
<p>Design a 2D straight-line type <code>Line</code></p>
<ul>
<li><code>Line</code> can be constructed by supplying two endpoints</li>
<li><code>Line</code> has a method <code>is_point_on_line()</code> which checks whether a given point belongs to the line or not</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64
</span><span class="boring">}
</span><span class="boring">impl MyPoint {
</span><span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">}
</span>// ... add here your implementation of Line and its methods
// ...
fn main() {
    let point1 = MyPoint::new(2., 1.);
    let point2 = MyPoint::new(-2., -1.);
    let segment1 = Line::new(point1, point2);
    let point3 = MyPoint::new(4., 2.);
    assert_eq!(segment1.is_point_on_line(point3), true);
    // let point4 = MyPoint::new(1., 1.);
    // assert_eq!(segment2.is_point_on_line(point4), false);
}
</code></pre></pre>
<!-- struct Line(MyPoint, MyPoint); -->
<!-- impl Line { -->
<!--     fn new(point1: MyPoint, point2: MyPoint) -> Self { -->
<!--         Self(point1, point2) -->
<!--     } -->
<!--     fn is_point_on_line(self, point: MyPoint) -> bool { -->
<!--         let vector1 = MyPoint::new(self.0.x - self.1.x, self.0.y - self.1.y); -->
<!--         let vector2 = MyPoint::new(point.x - self.1.x, point.y - self.1.y); -->
<!--         (vector1.x * vector2.y - vector1.y * vector2.x).abs() < 10. * f64::EPSILON -->
<!--     } -->
<!-- } -->
<blockquote>
<p>(*) Implement a type <code>Triangle</code> (you may choose between 2D and 3D triangles)</p>
<ul>
<li><code>Triangle</code> can be constructed based on three vertices</li>
<li><code>Triangle</code> has a method to check whether a given point lies within it or not</li>
</ul>
</blockquote>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Array is a fixed-size collection of elements of the <em>same</em> type (similar to C arrays)</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut array = [7, 21, 42];
    array[0] += 20;
    println!(&quot;{:?}&quot;, array);
}
</code></pre></pre>
<ul>
<li>Note the <code>{:?}</code> syntax which normally tells to dump the contents of the variable. We will elaborate on this <a href="./traits.html">later</a>, while discussing the <code>Debug</code> trait.</li>
</ul>
<p>What happens if we access an index out of range?</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [7, 21, 42];
    let mut index = 0;
    loop {
        println!(&quot;The element #{} is {}&quot;, index, array[index]);
        index += 1;
    }
}
</code></pre></pre>
<ul>
<li>It is safe to do (i.e., no undefined behaviour), the Rust program just panics</li>
<li><code>loop</code> denotes an infinite loop (a dedicated language construct, unlike the hacky <code>while(1)</code> and <code>for(;;)</code> in C)</li>
</ul>
<p>More idiomatic (and less error-prone) alternative is to use Rust <em>iterators</em></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [7, 21, 42];
    for (index, element) in array.iter().enumerate() {
        println!(&quot;The element #{} is {}&quot;, index, element);
    }
}
</code></pre></pre>
<p>In the next exercise, we mock a 5x5 LED matrix, which resembles the Micro:bit peripheral from the <a href="./blink.html">Embedded Rust part</a></p>
<blockquote>
<h4 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h4>
<p>Implement a method <code>display()</code> for the type <code>LedMatrix</code> below which prints '.' for each 0 and '*' for each 1 that it encounters in <code>pattern</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct LedMatrix {
    // Syntax for a nested array of size 5x5
    pattern: [[u8; 5]; 5]
}
// Add your code here ...
fn main() {
    let light_pattern = [
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 0, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
    ];
    let matrix = LedMatrix{pattern: light_pattern};
    matrix.show();
    // The command above should print
    // *****
    // *****
    // **.**
    // *****
    // *****
}
</code></pre></pre>
<blockquote>
<h4 id="exercise-2"><a class="header" href="#exercise-2">Exercise</a></h4>
<p>(*) Extend the code so that it works for LED matrices of different sizes. It's tricky to have a variable-size data structure without heap allocation and <code>std</code> library, so we will pre-allocate an array of big enough size instead</p>
<ul>
<li><code>LedMatrix</code> now needs an extra field to indicate the <em>logical</em> size of the pattern,</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Syntax for a compile-time constant (let will not work here)
const STATIC_DIMENSION: usize = 5;
struct LedMatrix {
    pattern: [[u8; STATIC_DIMENSION]; STATIC_DIMENSION],
    dimension: usize
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<ul>
<li>Add the <code>new()</code> method, which constructs an instance of <code>LedMatrix</code> that has an extra parameter <code>dimension</code>. Make the runtime check whether <code>dimension</code> has a valid value. <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> if things go wrong.</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LedMatrix {
    fn new(pattern: [[u8; STATIC_DIMENSION]; STATIC_DIMENSION], dimension: usize) -&gt; Self {
// Add your code here ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<ul>
<li>Adjust <code>show()</code> so that it prints only the actually used part of the pattern</li>
</ul>
</blockquote>
<!-- impl LedMatrix { -->
<!--     fn new(pattern: [[u8; STATIC_DIMENSION]; STATIC_DIMENSION], dimension: usize) -> Self { -->
<!--         if dimension > STATIC_DIMENSION { -->
<!--             panic!("Size cannot exceed {}!", STATIC_DIMENSION); -->
<!--         } -->
<!--         Self{pattern: pattern, dimension: dimension} -->
<!--     } -->
<!--     fn show(self) { -->
<!--         for i in 0..self.dimension { -->
<!--             for j in 0..self.dimension { -->
<!--                 if self.pattern[i][j] == 0 { -->
<!--                     print!("."); -->
<!--                 } -->
<!--                 else { -->
<!--                     print!("*"); -->
<!--                 } -->
<!--             } -->
<!--             println!(""); -->
<!--         } -->
<!--     } -->
<!-- } -->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let matrix1 = LedMatrix::new([[1; STATIC_DIMENSION]; STATIC_DIMENSION], 3);
    matrix1.show();
    // The command above should print
    // ***
    // ***
    // ***
    let matrix2 = LedMatrix::new([[0; STATIC_DIMENSION]; STATIC_DIMENSION], 10);
    // Here, a panic should happen
    matrix2.show();
}
</code></pre></pre>
<h2 id="resources-for-deeper-understanding"><a class="header" href="#resources-for-deeper-understanding">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html">Chapter 3</a>, <a href="https://doc.rust-lang.org/book/ch05-00-structs.html">Chapter 5</a> and <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">here</a> in the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrow-checker"><a class="header" href="#ownership-and-borrow-checker">Ownership and borrow checker</a></h1>
<h2 id="warm-up-example"><a class="header" href="#warm-up-example">Warm-up example</a></h2>
<p>The code below looks good, we only call the struct method twice. Why is compiler not happy?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span>impl MyPoint {
<span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">
</span>    fn is_close_to_origin(self) -&gt; bool {
        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
    }
}

fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<p>At the same time, the following example is compiling without issues:</p>
<pre><pre class="playground"><code class="language-rust editable">fn print_me(x: i32) {
    println!(&quot;The value is {}&quot;, x);
}

fn main() {
    let x = 5;
    let y = x;
    print_me(x);
    print_me(x);
    print_me(y);
}
</code></pre></pre>
<p>What's the difference?</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>The ownership and access system in Rust is quite restrictive and also non-intuitive at first for developers with C++/Java/C# background. As we will see, the reason is to guarantee safety, at compile time.</p>
<!-- In this Section, we will use the [RustViz](https://github.com/rustviz/rustviz) tool to visualize the ownership and access concepts. -->
<p>Here are the basic rules for ownership:</p>
<ul>
<li>Values in Rust have only <em>one</em> owner at a time, meaning there is <em>one and only one</em> responsible for deallocating the value when it's not needed anymore.
<ul>
<li>No memory leaks or <a href="https://stackoverflow.com/a/21057524">double frees</a> anymore</li>
<li>Owner can change over time by <em>moving</em> the value, but at any given time there is only one owner. The old owner is said to be <em>consumed</em> in this case.
<ul>
<li>Move does not touch the value (neither the contents nor the memory location), no non-trivial move constructors (a la C++) are allowed</li>
</ul>
</li>
</ul>
</li>
<li>Deallocation is similar to RAII in C++: the value is droppped when the last owner goes out of scope</li>
<li>All the potential code locations for deallocation can be determined at compile-time, so no need for garbage collection (unlike Java and C#)</li>
</ul>
<p>It explains the problem with the double call,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
<span class="boring">}
</span></code></pre></pre>
<p>since <code>point</code> is consumed at the first call of <code>is_close_to_origin()</code>.</p>
<p>But why then <code>x</code> is not consumed in the second example above?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>i32</code>, as well as many other stack-allocated types, can be efficiently copied by directly copying the bits</li>
<li>These types have <code>Copy</code> trait, which we cover in more detail in the <a href="./traits_generics.html">next Section</a></li>
<li>Rust <em>always copies</em> types with <code>Copy</code> instead of moving them (on every assignment and passing to function)</li>
<li><code>MyPoint</code> has only stack-allocated values inside, can't we make it <code>Copy</code> as well? Yes, we can:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Copy,Clone)]
struct MyPoint {
    x: f64,
    y: f64,
}
<span class="boring">impl MyPoint {
</span><span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">    fn is_close_to_origin(self) -&gt; bool {
</span><span class="boring">        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<ul>
<li>No accidental implicit copies for non-<code>Copy</code> types are possible! (in contrast with C++)</li>
</ul>
<blockquote>
<h4 id="exercise-3"><a class="header" href="#exercise-3">Exercise</a></h4>
<p>...
+</p>
</blockquote>
<h2 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow checker</a></h2>
<p>We don't actually need an independent copy of <code>MyPoint</code> on every method call. (We get now in total 3 different copies of the same value!) What we really need is to read the value, how to do that? <em>Borrowing</em> is the way to go.</p>
<p>Borrow rules:</p>
<ul>
<li>You can access a value without owning it. You are then <em>borrowing</em> it, which basically means you have a reference (or a pointer, if we dig at lower level) to the value</li>
<li>You either:
<ul>
<li>only read the value contents (<em>immutable borrow</em>), the syntax is <code>&amp;T</code> OR</li>
<li>both read and write (<em>mutable borrow</em>), the syntax is <code>&amp;mut T</code></li>
</ul>
</li>
<li>You can have <em>multiple immutable</em> borrows OR a <em>single mutable</em> borrow (not both at the same time)
<ul>
<li>Immutable borrow means not only that you can't change the value, but nobody else can do that either!</li>
</ul>
</li>
</ul>
<p>Compiler makes sure that</p>
<ul>
<li>References are always valid</li>
<li>In particular, they are not null pointers</li>
</ul>
<p>So what we need for the previous example is an immutable borrow:</p>
<pre><pre class="playground"><code class="language-rust">struct MyPoint {
    x: f64,
    y: f64,
}
impl MyPoint {
<span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span>    fn is_close_to_origin(&amp;self) -&gt; bool {
        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
    }
}

fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<ul>
<li>Note that we've removed <code>#[derive(...)]</code> as we don't need to copy the values anymore</li>
</ul>
<h2 id="resources-for-deeper-understanding-1"><a class="header" href="#resources-for-deeper-understanding-1">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Chapter 4</a> of the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-and-generics"><a class="header" href="#traits-and-generics">Traits and generics</a></h1>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<ul>
<li>Good for dependency injection and mocking while testing</li>
<li>Some objects can be neither copied nor cloned (makes sense for a unique resource like an open file)</li>
</ul>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Real-world trait: <a href="https://doc.rust-lang.org/core/fmt/trait.Write.html">core::fmt::Write</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Write {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; Result;

    fn write_char(&amp;mut self, c: char) -&gt; Result { ... }
    fn write_fmt(&amp;mut self, args: Arguments&lt;'_&gt;) -&gt; Result { ... }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>This trait is normally used for unbuffered writes (like appending characters to a string)</li>
<li>Good thing: you only need to implement <code>write_str()</code>, the other two methods are provided automatically</li>
<li>Allows to use <code>println!</code>-like formatted printing</li>
</ul>
<pre><code class="language-rust noplayground">    // w implements core::fmt::Write
    // ...
    write!(w, &quot;Formatted {}&quot;, &quot;printing&quot;).unwrap();
</code></pre>
<ul>
<li>We will use this feature later for <a href="./serial.html">serial communication</a></li>
</ul>
<blockquote>
<h4 id="exercise-4"><a class="header" href="#exercise-4">Exercise</a></h4>
<p>Implement a struct that implements <code>core::fmt::Write</code>, so that writing to that struct does several things:</p>
<ul>
<li>The message contents is printed on screen</li>
<li>An internal statistical counter is updated (side effect). The counter keeps track of total number of characters being ever written</li>
<li>(*) Every second time you write to the struct, the counter value is printed on screen</li>
<li>(**) You print only whenever end-of-line is encountered in your message, but buffer the message otherwise (similar to <code>printf()</code> in C). Yes, <code>core::fmt::Write</code> is used for <em>unbuffered</em> writes, so such an implementation is not recommended for production use :-)</li>
</ul>
</blockquote>
<p>Copy, Clone, Debug...</p>
<h2 id="resources-for-deeper-understanding-2"><a class="header" href="#resources-for-deeper-understanding-2">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Chapter 10</a> of the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<h2 id="todo-1"><a class="header" href="#todo-1">TODO</a></h2>
<ul>
<li>Pattern matching</li>
</ul>
<p>What do we do whenever a function either returns either some value or <em>no value at all</em>?</p>
<ul>
<li>In C, and in the old-style C++, we use a null pointer for the latter case</li>
<li>In Rust, it is idiomatic to use <a href="https://doc.rust-lang.org/core/option/enum.Option.html"><code>core::option::Option</code></a>:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>Option</code> is similar to C++ <code>std::optional</code>, which was introduced only in C++17</li>
</ul>
<p><code>Option</code> has many batteries included:</p>
<ul>
<li><code>#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]</code></li>
<li>Plenty of helper functions</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: Option&lt;u8&gt; = Some(2);
    assert_eq!(x.is_some(), true);
    assert_eq!(x.unwrap(), 2);
    assert_eq!(x.expect(&quot;Oops!&quot;), 2);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: Option&lt;u8&gt; = None;
    x.expect(&quot;Oops!&quot;);
}
</code></pre></pre>
<p>Whenever an operation may <em>fail</em>, it is idiomatic to use <a href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>core::result::Result</code></a> instead</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>It has a set of batteries very similar to <code>Option</code></li>
<li>If a function returns a <code>Result</code> and the caller ignores the returned value, the compiler gives a warning</li>
<li>It is very popular to use the <code>?</code> syntactic sugar to propagate errors in an elegant way:</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn problematic_function() -&gt; Result&lt;u8, ()&gt; {
    let x: Result&lt;u8, ()&gt; = Err(());
    println!(&quot;{:?}&quot;, x?);
    Ok(4)
}

fn main() {
    println!(&quot;{:?}&quot;, problematic_function());
}
</code></pre></pre>
<ul>
<li>Compare this approach with C++/Java/Python exceptions, where error propagation is <em>non-local</em> and you may easily get an exception at runtime that you were not even aware of and which crashes the application! (Or even worse, bloat the code with catching all potential exceptions in a paranoic fashion, just to be on the safe side.)</li>
</ul>
<h2 id="resources-for-deeper-understanding-3"><a class="header" href="#resources-for-deeper-understanding-3">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Chapter 6</a>, <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">also here</a> and <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">here</a> in the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-makes-embedded-rust-special"><a class="header" href="#what-makes-embedded-rust-special">What makes Embedded Rust special</a></h1>
<h2 id="embedded-vs-os-based-application-development"><a class="header" href="#embedded-vs-os-based-application-development">Embedded vs. OS-based application development</a></h2>
<p>Things that are easy to use from ordinary (non-embedded) applications:</p>
<ul>
<li>Heap allocation</li>
<li>Run a new process (you just specify the executable file, OS loads it automatically)</li>
<li>Spawn new threads and communicate between them</li>
<li>Security
<ul>
<li>You don't even notice other processes unless you really want to</li>
<li>OS takes care of emergency situations like the <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow</a></li>
</ul>
</li>
<li>Read/write/create a file</li>
<li>Networking (TCP/IP)
In general, it is relatively easy to write OS-agnostic code (apart from some things are not portable in principle).</li>
</ul>
<p>In bare-metal embedded systems, you normally instead</p>
<ul>
<li>Avoid heap whatsoever (RAM is quite limited)</li>
<li>Make your own custom scheduler to provide multi-tasking
<ul>
<li>You often need a real-time response (e.g. every 1 millisecond, you need to finish processing new chunk of sensor data)</li>
<li>Data races between different tasks are easily introduced</li>
</ul>
</li>
<li>Are responsible for writing your application into permanent (flash) memory and then initialize the RAM layout at runtime</li>
<li>Have access to all the peripherals - easy to ruin everything</li>
<li>Write/tailor drivers for the I/O (like accessing an SD card or an Ethernet controller)</li>
<li>Have to understand board-specific hardware aspects even simply to make sure your software doesn't burn the board
<ul>
<li>Logic interfacing, motor control, power supplies, etc.</li>
</ul>
</li>
</ul>
<p>Embedded development sounds scary... Can Rust help here?</p>
<h2 id="embedded-rust"><a class="header" href="#embedded-rust">Embedded Rust</a></h2>
<p>Embedded Rust is different from normal Rust:</p>
<ul>
<li>You don't have access to the Rust <a href="https://doc.rust-lang.org/std/">standard library</a> (no off-the-shelf variable-size data structures and I/O).
<ul>
<li>Nevertheless all of the <code>core</code> (i.e., almost all that we've covered in previous Sections) is available.</li>
</ul>
</li>
<li>No ordinary <code>main()</code> as the default entry point <!-- : you have to do the steps preceding `main()` as well. -->
<ul>
<li>The standard <code>main()</code> expects command-line arguments as input, which don't make sense in the embedded context. And you never return from <code>main()</code> either.</li>
</ul>
</li>
<li>Panic behaviour is undefined by default: you can (and should) tailor it to your needs.</li>
</ul>
<p>You can work at 3 different abstraction layers:</p>
<ul>
<li>Peripheral-Access Crate (PAC) is the lowest layer, you access here individual MCU registers. <a href="https://crates.io/crates/nrf52833-pac/">nrf52833-pac</a> is the PAC that we actually use under the hood for Micro:bit V2. This crate is generated automatically from an <a href="https://raw.githubusercontent.com/nrf-rs/nrf-pacs/master/svds/nrf52833.svd">XML file</a> provided by the manufacturer.
<ul>
<li>Normally you want to stay away from this layer, unless higher-level layers do no provide all the functionality you need (or maybe you need to <em>optimize</em> the existing functionality).</li>
</ul>
</li>
<li>Hardware-Abstraction Layer (HAL) is a way to abstract the <em>MCU</em> peripherals into structs and methods. We will use <a href="https://crates.io/crates/nrf52833-hal">nrf52833-hal</a>.
<ul>
<li>As an example, at this layer you can create and start a built-in hardware timer or establish a serial (UART) communication.</li>
<li>HALs in the Rust ecosystem normally build on top of the <a href="https://docs.rs/embedded-hal/"><code>embedded-hal</code></a> crate, which is basically a collection of universal traits like <a href="https://docs.rs/embedded-hal/latest/embedded_hal/digital/v2/trait.OutputPin.html"><code>digital::v2::OutputPin</code></a> for an output pin.</li>
<li>A lot of platform-agnostic drivers are written based on <code>embedded-hal</code>.</li>
</ul>
</li>
<li>Board Support Package (BSP) is the highest layer, and provides access to all the peripherals of the board (not only the ones built into MCU) like the accelerometer and the LED.</li>
<li>More explanation on different layers is <a href="https://docs.rust-embedded.org/discovery/microbit/04-meet-your-hardware/terminology.html">here</a>, together with a useful videolink.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-embedded-world"><a class="header" href="#hello-embedded-world">Hello, Embedded world!</a></h1>
<h2 id="setting-up-the-environment-1"><a class="header" href="#setting-up-the-environment-1">Setting up the environment</a></h2>
<p>Apart from the general Rust environment (including the Rust compiler and Cargo) that we have since <a href="./setting_up.html">this Section</a>, we need embedded-specific tools. Their setup on different OS platforms is described in the <a href="https://docs.rust-embedded.org/discovery/microbit/03-setup/index.html">Discovery book</a>. Make sure you look at the instructions for Micro:bit V2 (not V1)!</p>
<h2 id="first-code-example"><a class="header" href="#first-code-example">First code example</a></h2>
<p>Get template that is tailored to our board from <a href="https://github.com/tyomaiva/first-rust-course/blob/master/microbit_template">GitHub</a>. For more details, look at the <a href="https://github.com/rust-embedded/cortex-m-quickstart">original template</a>.</p>
<p>Run it so: ???</p>
<pre><code class="language-rust noplayground">// We don't have access to the Rust standard library
#![no_std]
// There is no standard main(), we cook it up ourselves
#![no_main]

// Implements a panic handler for us.
// The handler conveniently logs the error message to RTT before entering an infinite loop.
use panic_rtt_target as _;
// Enables to capture the output from Micro:bit while debugging, using the so-called
// Real-Time Transfer (RTT). Look at https://docs.rs/rtt-target/ for more details.
use rtt_target::{rprintln, rtt_init_print};
// The import is unused, but otherwise the linker
// somehow cannot find the interrupt table
use microbit::hal::prelude::*;

use cortex_m_rt::entry;

// That is the actual entry point of our program
#[entry]
// '!' means that the function never returns
fn main() -&gt; ! {
    // This should be called once (and only once) in order to set up RTT
    rtt_init_print!();
    rprintln!(&quot;Hello Embedded world, do you mind if I join?&quot;);
    loop {}
}
</code></pre>
<ul>
<li><code>cortex_m_rt</code> does linking (based on the layout in <code>memory.x</code> file) and RAM initialization for ARM Cortex-M chips</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-microbit"><a class="header" href="#what-is-microbit">What is Micro:bit?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-led-matrix"><a class="header" href="#the-led-matrix">The LED matrix</a></h1>
<p>Now it's time to control some of the board peripherals, we start with the 5x5 LED matrix. The new things that we need compared to the &quot;Hello World&quot; example are</p>
<pre><code class="language-rust noplayground">// Add your code here ...
use microbit::{
    board::Board,
    display::blocking::Display,
    hal::Timer,
};
// Add your code here ...
#[entry]
fn main() -&gt; ! {
// Add your code here ...
    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);
//  Add your code here ...
}
</code></pre>
<ul>
<li><code>board</code> is a struct with all the peripherals we have, see <a href="https://docs.rs/microbit-v2/latest/microbit/board/struct.Board.html">here</a>
<ul>
<li><code>TIMER0</code> is one of the 5 hardware timers available on the board</li>
<li><code>display_pins</code> are the 10 GPIO pins that control the LED matrix
<ul>
<li>(*) How can 10 pins control 5 * 5 = 25 LEDs?</li>
</ul>
</li>
</ul>
</li>
<li>You can use methods <code>show()</code> and <code>clear()</code> of the struct <a href="https://docs.rs/microbit-v2/latest/microbit/display/blocking/struct.Display.html"><code>microbit::display::blocking::Display</code></a> to manipulate the LED state.</li>
<li>To introduce time delays (&quot;sleeps&quot;), the method <code>delay_ms()</code> is available for <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Timer.html"><code>microbit::hal::Timer</code></a>.</li>
</ul>
<blockquote>
<h4 id="exercise-5"><a class="header" href="#exercise-5">Exercise</a></h4>
<ul>
<li>Make the matrix to light a pattern (e.g., all LEDs are on) for 1 second, then switch to another pattern (e.g., all LEDs are off) for another second, and repeat this switching indefinitely.</li>
<li>(*) Make a dice: every second, light up one of 6 dice patterns, either in a deterministi fashion (e.g., first you show 1, then 2, and so on) or randomly (you can use the <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Timer.html#method.read"><code>hal::Timer::read()</code></a> method for generating random numbers).</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serial-communication-with-uart"><a class="header" href="#serial-communication-with-uart">Serial communication with UART</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="putting-all-together-streaming-data-from-the-accelerometer"><a class="header" href="#putting-all-together-streaming-data-from-the-accelerometer">Putting all together: streaming data from the accelerometer</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="rustviz_plugin/helpers.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
