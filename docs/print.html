<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Course</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Basics of Rust</li><li class="chapter-item expanded "><a href="setting_up.html"><strong aria-hidden="true">2.</strong> Setup</a></li><li class="chapter-item expanded "><a href="syntax_basics.html"><strong aria-hidden="true">3.</strong> Syntax basics</a></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">4.</strong> Ownership and borrow checker</a></li><li class="chapter-item expanded "><a href="traits_generics.html"><strong aria-hidden="true">5.</strong> Traits and generics</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">6.</strong> Enums</a></li><li class="chapter-item expanded affix "><li class="part-title">Embedded Rust</li><li class="chapter-item expanded "><a href="embedded_introduction.html"><strong aria-hidden="true">7.</strong> What makes Embedded Rust special</a></li><li class="chapter-item expanded "><a href="hello_embedded_world.html"><strong aria-hidden="true">8.</strong> Hello, Embedded world!</a></li><li class="chapter-item expanded "><a href="microbit_introduction.html"><strong aria-hidden="true">9.</strong> What is Micro:bit?</a></li><li class="chapter-item expanded "><a href="blink.html"><strong aria-hidden="true">10.</strong> The LED matrix</a></li><li class="chapter-item expanded "><a href="serial.html"><strong aria-hidden="true">11.</strong> Serial communication with UART</a></li><li class="chapter-item expanded "><a href="accelerometer_streaming.html"><strong aria-hidden="true">12.</strong> Putting all together: streaming data from the accelerometer</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to a Rust programming language course!</p>
<p>The goals of the course:</p>
<ul>
<li>Learn to write basic Rust code and read API docs like <a href="https://doc.rust-lang.org/core/option/enum.Option.html">this</a></li>
<li>Get experience with Embedded Rust on a real hardware platform</li>
</ul>
<p><em>Out</em> of scope:</p>
<ul>
<li>Motivation to learn Rust (we tried to accomplish that in the previous sessions)</li>
<li>Data collections like <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a> or <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html">HashMap</a>, since they involve heap allocation, which is often undesirable in embedded systems. Also no file access and no other forms of I/O (printing to standard output is the only exception). In general, we omit the Rust standard library.</li>
<li>Multithreading and asynchronous programming, though both are quite easy with Embedded Rust (see <a href="https://embassy.dev/">here</a> and <a href="https://rtic.rs/1/book/en/">here</a>), and almost unavoidable when implementing an RTOS</li>
<li>Unit testing, modularization, and other good development practices, since all of our projects will be very small</li>
<li>PAC layer of Embedded Rust. We start directly with the higher abstraction levels which are HAL and BSP. So no direct register manipulation.</li>
</ul>
<!-- + Smart pointers like [Box](https://doc.rust-lang.org/std/boxed/struct.Box.html), for the same reason -->
<!-- What knowledge is expected: -->
<!-- + how stack/heap works -->
<!-- + UNIX shell (e.g. bash) ?????????? -->
<!-- + C++ experience is useful, as we will draw analogies and make comparisons from time to time -->
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a> is a nice crash course without much theory. Note: it may actually take more than 30 minutes to read and digest ðŸ˜Š</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/">Teaching material</a> developed by Ferrous Systems, a company which specializes in Rust development (including Embedded Rust) and in providing Rust trainings</li>
<li>The official <a href="https://doc.rust-lang.org/book/">Rust book</a> is written extremely clear and is quite comprehensive. Absolute recommendation if you are serious about Rust!</li>
<li><a href="https://docs.rust-embedded.org/discovery/microbit/">The Discovery book</a> is an introductory resource on Embedded Rust using the same hardware platform that we cover here</li>
</ul>
<p style="text-align: center;"><img src="https://visitor-badge.glitch.me/badge?page_id=https://tyomaiva.github.io/first-rust-course/&left_color=green&right_color=red" alt="Visitors" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<blockquote>
<p><em>Note</em>: this Section is optional for the first part of the course. You need it only whenever you want to run the code examples <em>locally</em> on your system. Otherwise, use the online sandbox <a href="https://play.rust-lang.org/">Rust Playground</a>.
However, for the embedded part, this Section is mandatory, since we want to interface our physical microcontroller boards.</p>
</blockquote>
<h2 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting up the environment</a></h2>
<p>If something below goes wrong, go for more details to <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">https://doc.rust-lang.org/book/ch01-01-installation.html</a></p>
<h3 id="installing-rust-on-windows"><a class="header" href="#installing-rust-on-windows">Installing Rust on Windows</a></h3>
<p>Before installing Rust, it also requires the C++ build tools. In case you do not have those, you can get them via this link: <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">https://visualstudio.microsoft.com/visual-cpp-build-tools/</a></p>
<p>To install Rust itself, go to the following link and follow the instructions for installation: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>
<h3 id="installing-rust-on-linux-or-macos"><a class="header" href="#installing-rust-on-linux-or-macos">Installing Rust on Linux or macOS</a></h3>
<p>The following command downloads and installs the latest stable version of Rust:</p>
<pre><code class="language-shell">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Rust also needs a C linker. In case you do not have one, do the following:</p>
<ul>
<li>For <strong>Linux</strong></li>
</ul>
<pre><code class="language-shell">sudo apt-get update
sudo apt install build-essential
</code></pre>
<ul>
<li>For <strong>macOS</strong></li>
</ul>
<pre><code class="language-shell">xcode-select install
</code></pre>
<h3 id="what-ides-can-be-used"><a class="header" href="#what-ides-can-be-used">What IDEs can be used?</a></h3>
<p>Mainly for syntax highlighting, code completion, etc. Both have Rust plugins:</p>
<ul>
<li>Visual Studio Code (<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a>)</li>
<li>IntelliJ IDEA</li>
</ul>
<h2 id="setting-up-a-basic-project"><a class="header" href="#setting-up-a-basic-project">Setting up a basic project</a></h2>
<p>We will use Cargo, which comes with the Rust installation. What does it do?</p>
<ul>
<li>Package manager (e.g., it fetches and builds external dependencies)</li>
<li>Build system (it compiles your packages)</li>
</ul>
<p>Cargo can be used to generate a new Rust project template, by running the following in your shell:</p>
<pre><code class="language-shell">cargo new my_rust_sandbox
cd my_rust_sandbox
</code></pre>
<p>Inside the new directory,</p>
<ul>
<li><em>src</em> sub-directory is generated with a file inside called <em>main.rs</em> which contains a &quot;Hello World!&quot; program. In order to run examples from the next Sections, just copy the code from an example and replace the contents of this file with that.</li>
<li><em>Cargo.toml</em> file is generated which basically configures your program. We don't need any external dependencies for the first part of the course, so this file can be kept untouched.</li>
</ul>
<p>To (re-)build and run the executable, use</p>
<pre><code class="language-shell">cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-basics"><a class="header" href="#syntax-basics">Syntax basics</a></h1>
<!-- + `use` creates shorthand aliases, so instead of typing `std::io::stdin()` we type `io::stdin()` -->
<h2 id="first-code-snippet"><a class="header" href="#first-code-snippet">First code snippet</a></h2>
<blockquote>
<p>You can edit and run most of the code snippets on this page without leaving your browser. Alternatively, you can copy them to the <a href="https://play.rust-lang.org/">Rust Playground</a> and run there</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut index = 10; // Define a variable
    while index != 0 {
        println!(&quot;Counting down: {}&quot;, index);
        /* Decrease the value on each iteration */
        index -= 1;
    }
}
</code></pre></pre>
<p>Several things to note here:</p>
<ul>
<li><code>fn</code> defines a new function, in this case it is called <code>main</code>, it does not have any input arguments and does not return anything either. <code>main()</code> is the entry point of the program.</li>
<li><code>let mut</code> binds a value <code>10</code> to a <em>mutable</em> variable called <code>index</code>
<ul>
<li>If you omit <code>mut</code>, you get instead an <em>immutable</em> variable, which does not work in this case, try it!</li>
<li>So variables in Rust are immutable by default</li>
</ul>
</li>
<li>Syntax is similar to C and languages that (partially) inherited the C syntax (like C++, Java, and JavaScript): brackets, braces, semicolons, comparison and increment/decrement operators, comments</li>
<li><code>println!()</code> does formatted printing, similar to <code>printf()</code> in C, but more powerful</li>
</ul>
<h2 id="basic-built-in-types"><a class="header" href="#basic-built-in-types">Basic built-in types</a></h2>
<p>In the example above, the type of the variable <code>index</code> is inferred automatically</p>
<ul>
<li>In that case it is <code>i32</code>, which is a 32-bit signed integer</li>
<li>You can get this information by hovering over <code>index</code> in your IDE with Rust Language Server enabled (e.g. in Visual Studio Code)</li>
<li>If we change <code>10</code> to <code>10.</code>, we get instead the double-precision floating-point type, <code>f64</code></li>
<li>If you want to use a different type, you need to specify it explicitly</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let index: u8 = 10;
    // OR
    let index = 10_u8;
    // OR
    let index = 10 as u8;
}
</code></pre></pre>
<ul>
<li><code>u8</code> is 8-bit unsigned integer type, which is very popular in Embedded Rust and in general in low-level programming, where we have to shuffle individual bytes</li>
<li><code>usize</code> is another extremely popular type, which is an unsigned integer with native size (32-bit for 32-bit architectures like ARM Cortex-M, 64-bit for a desktop/laptop CPU)</li>
<li><code>bool</code> is a type with two possible values: <code>true</code> and <code>false</code></li>
<li>More types here: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#scalar-types">Scalar Types</a></li>
</ul>
<h2 id="user-defined-types"><a class="header" href="#user-defined-types">User-defined types</a></h2>
<p>Apart from the basic types, we often want to combine them in a <em>compound</em> user-defined type</p>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<!-- tuples go before arrays as an example for the latter needs an iterator that produces a tuple -->
<p>A tuple combines values of different types</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let tuple = (&quot;Something&quot;, 2);
    println!(&quot;The tuple contents are: {}, {}&quot;, tuple.0, tuple.1);
}
</code></pre></pre>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Structs are similar to tuples in that they combine potentially different types, but each field is <em>named</em> and the struct type itself has a name:</p>
<pre><pre class="playground"><code class="language-rust editable">struct MyPoint {
    x: f64,
    y: f64,
}
fn main() {
    let point = MyPoint{x: 3., y: 4.};
    println!(&quot;The point coordinates are: x: {}, y: {}&quot;, point.x, point.y);
}
</code></pre></pre>
<ul>
<li>Note that if you pass <code>{x: 3, y: 4}</code> instead of <code>{x: 3., y:4.}</code>, you get a compiler error (try it!): you need to convert the types explicitly, e.g. <code>{x: 3 as f64, y: 4 as f64)</code> will do the trick. It is a safety feature, to avoid accidental type castings</li>
</ul>
<p>You can associate methods with the struct type (encapsulation):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span>impl MyPoint {
    fn new(x: f64, y: f64) -&gt; Self {
        Self{x: x, y: y}
    }

    fn is_close_to_origin(self) -&gt; bool {
        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
    }
}

fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<ul>
<li>Implementing <code>new()</code> is a customary way of initializing structs. It's like a class constructor in C++, with two major differences:
<ul>
<li>Call of <code>new()</code> should be always <em>explicit</em> (no implicit construction)</li>
<li>There can be only one implementation of <code>new()</code>, since Rust intentionally does not have function overloading. If you need multiple ways to construct an object (e.g. construct a default struct value and a custom one), use the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">Builder pattern</a> instead</li>
</ul>
</li>
<li><code>Self</code> is an alias to the current struct <em>type</em>, so <code>Self</code> \( \iff \) <code>MyPoint</code></li>
<li><code>self</code> is an alias to the current struct <em>instance</em>, so <code>self</code> \( \iff \) <code>point</code></li>
<li><a href="https://doc.rust-lang.org/beta/core/macro.assert_eq.html"><code>assert_eq!(a, b)</code></a> checks if <code>a == b</code>, if not, it panics (i.e., the whole process is shut down in a safe way and a diagnostic post-mortem message gets written).</li>
</ul>
<blockquote>
<h4 id="exercise"><a class="header" href="#exercise">Exercise</a></h4>
<p>Design a 2D straight-line type <code>Line</code></p>
<ul>
<li><code>Line</code> can be constructed by supplying two endpoints</li>
<li><code>Line</code> has a method <code>is_point_on_line()</code> which checks whether a given point belongs to the line or not</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64
</span><span class="boring">}
</span><span class="boring">impl MyPoint {
</span><span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">}
</span>// ... add here your implementation of Line and its methods
// ...
fn main() {
    let point1 = MyPoint::new(2., 1.);
    let point2 = MyPoint::new(-2., -1.);
    let segment1 = Line::new(point1, point2);
    let point3 = MyPoint::new(4., 2.);
    assert_eq!(segment1.is_point_on_line(point3), true);
}
</code></pre></pre>
<!-- struct Line(MyPoint, MyPoint); -->
<!-- impl Line { -->
<!--     fn new(point1: MyPoint, point2: MyPoint) -> Self { -->
<!--         Self(point1, point2) -->
<!--     } -->
<!--     fn is_point_on_line(self, point: MyPoint) -> bool { -->
<!--         let vector1 = MyPoint::new(self.0.x - self.1.x, self.0.y - self.1.y); -->
<!--         let vector2 = MyPoint::new(point.x - self.1.x, point.y - self.1.y); -->
<!--         (vector1.x * vector2.y - vector1.y * vector2.x).abs() < 10. * f64::EPSILON -->
<!--     } -->
<!-- } -->
<blockquote>
<p>(*) Implement a type <code>Triangle</code> (you may choose between 2D and 3D triangles)</p>
<ul>
<li><code>Triangle</code> can be constructed based on three vertices</li>
<li><code>Triangle</code> has a method to check whether a given point lies within it or not</li>
</ul>
</blockquote>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Array is a fixed-size collection of elements of the <em>same</em> type (similar to C arrays)</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut array = [7, 21, 42];
    array[0] += 20;
    println!(&quot;{:?}&quot;, array);
}
</code></pre></pre>
<ul>
<li>Note the <code>{:?}</code> syntax which normally tells to dump the contents of the variable. We will elaborate on this <a href="./traits.html">later</a>, while discussing the <code>Debug</code> trait.</li>
</ul>
<p>What happens if we access an index out of range?</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [7, 21, 42];
    let mut index = 0;
    loop {
        println!(&quot;The element #{} is {}&quot;, index, array[index]);
        index += 1;
    }
}
</code></pre></pre>
<ul>
<li>It is safe to do (i.e., no undefined behaviour), the Rust program just panics</li>
<li><code>loop</code> denotes an infinite loop (a dedicated language construct, unlike the hacky <code>while(1)</code> and <code>for(;;)</code> in C)</li>
</ul>
<p>More idiomatic (and less error-prone) alternative is to use Rust <em>iterators</em></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [7, 21, 42];
    for (index, element) in array.iter().enumerate() {
        println!(&quot;The element #{} is {}&quot;, index, element);
    }
}
</code></pre></pre>
<p>In the next exercise, we mock a 5x5 LED matrix, which resembles the Micro:bit peripheral from the <a href="./blink.html">Embedded Rust part</a></p>
<blockquote>
<h4 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h4>
<p>Implement a method <code>display()</code> for the type <code>LedMatrix</code> below which prints '.' for each 0 and '*' for each 1 that it encounters in <code>pattern</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct LedMatrix {
    // Syntax for a nested array of size 5x5
    pattern: [[u8; 5]; 5]
}
// Add your code here ...
fn main() {
    let light_pattern = [
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 0, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
    ];
    let matrix = LedMatrix{pattern: light_pattern};
    matrix.show();
    // The command above should print
    // *****
    // *****
    // **.**
    // *****
    // *****
}
</code></pre></pre>
<blockquote>
<h4 id="exercise-2"><a class="header" href="#exercise-2">Exercise</a></h4>
<p>(*) Extend the code so that it works for LED matrices of different sizes. It's tricky to have a variable-size data structure without heap allocation and <code>std</code> library, so we will pre-allocate an array of big enough size instead</p>
<ul>
<li><code>LedMatrix</code> now needs an extra field to indicate the <em>logical</em> size of the pattern,</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Syntax for a compile-time constant (let will not work here)
const STATIC_DIMENSION: usize = 5;
struct LedMatrix {
    pattern: [[u8; STATIC_DIMENSION]; STATIC_DIMENSION],
    dimension: usize
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<ul>
<li>Add the <code>new()</code> method, which constructs an instance of <code>LedMatrix</code> that has an extra parameter <code>dimension</code>. Make the runtime check whether <code>dimension</code> has a valid value. <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> if things go wrong.</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LedMatrix {
    fn new(pattern: [[u8; STATIC_DIMENSION]; STATIC_DIMENSION], dimension: usize) -&gt; Self {
// Add your code here ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<ul>
<li>Adjust <code>show()</code> so that it prints only the actually used part of the pattern</li>
</ul>
</blockquote>
<!-- impl LedMatrix { -->
<!--     fn new(pattern: [[u8; STATIC_DIMENSION]; STATIC_DIMENSION], dimension: usize) -> Self { -->
<!--         if dimension > STATIC_DIMENSION { -->
<!--             panic!("Size cannot exceed {}!", STATIC_DIMENSION); -->
<!--         } -->
<!--         Self{pattern: pattern, dimension: dimension} -->
<!--     } -->
<!--     fn show(self) { -->
<!--         for i in 0..self.dimension { -->
<!--             for j in 0..self.dimension { -->
<!--                 if self.pattern[i][j] == 0 { -->
<!--                     print!("."); -->
<!--                 } -->
<!--                 else { -->
<!--                     print!("*"); -->
<!--                 } -->
<!--             } -->
<!--             println!(""); -->
<!--         } -->
<!--     } -->
<!-- } -->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let matrix1 = LedMatrix::new([[1; STATIC_DIMENSION]; STATIC_DIMENSION], 3);
    matrix1.show();
    // The command above should print
    // ***
    // ***
    // ***
    let matrix2 = LedMatrix::new([[0; STATIC_DIMENSION]; STATIC_DIMENSION], 10);
    // Here, a panic should happen
    matrix2.show();
}
</code></pre></pre>
<h2 id="resources-for-deeper-understanding"><a class="header" href="#resources-for-deeper-understanding">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html">Chapter 3</a>, <a href="https://doc.rust-lang.org/book/ch05-00-structs.html">Chapter 5</a> and <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">here</a> in the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrow-checker"><a class="header" href="#ownership-and-borrow-checker">Ownership and borrow checker</a></h1>
<h2 id="warm-up-example"><a class="header" href="#warm-up-example">Warm-up example</a></h2>
<p>The code below looks good, we only call the struct method twice. Why is compiler not happy?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span>impl MyPoint {
<span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">
</span>    fn is_close_to_origin(self) -&gt; bool {
        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
    }
}

fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<p>At the same time, the following example is compiling without issues:</p>
<pre><pre class="playground"><code class="language-rust editable">fn print_me(x: i32) {
    println!(&quot;The value is {}&quot;, x);
}

fn main() {
    let x = 5;
    let y = x;
    print_me(x);
    print_me(x);
    print_me(y);
}
</code></pre></pre>
<p>What's the difference?</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>The ownership and access system in Rust is quite restrictive and also non-intuitive at first for developers with C++/Java/C# background. As we will see, the reason is to guarantee safety, at compile time.</p>
<!-- In this Section, we will use the [RustViz](https://github.com/rustviz/rustviz) tool to visualize the ownership and access concepts. -->
<p>Here are the basic rules for ownership:</p>
<ul>
<li>Values in Rust have exactly <em>one</em> owner at a time, meaning there is <em>one and only one</em> responsible for deallocating the value when it's not needed anymore.
<ul>
<li>No memory leaks or <a href="https://stackoverflow.com/a/21057524">double frees</a> anymore.</li>
<li>Owner can change over time by <em>moving</em> the value, but at any given time there is only one owner. The old owner is said to be <em>consumed</em> in this case.
<ul>
<li>Move does not touch the value (neither the contents nor the memory location), no non-trivial move constructors (Ã  la C++) are allowed.</li>
</ul>
</li>
</ul>
</li>
<li>Owner always has a valid value as well
<ul>
<li>No unitialized data</li>
</ul>
</li>
<li>Deallocation is similar to RAII in C++: the value is droppped when the last owner goes out of scope
<ul>
<li>All the potential code locations for deallocation (typically there is only one location) can be determined at compile-time, so no need for garbage collection (unlike Java and C#)</li>
</ul>
</li>
</ul>
<p>It explains the problem with the double call,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
<span class="boring">}
</span></code></pre></pre>
<p>since <code>point</code> is consumed at the first call of <code>is_close_to_origin()</code>.</p>
<p>But why then <code>x</code> is not consumed in the second example above?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>i32</code>, as well as many other stack-allocated types, can be efficiently copied by directly copying the bits</li>
<li>These types have <code>Copy</code> trait, which we cover in more detail in the <a href="./traits_generics.html">next Section</a></li>
<li>Rust <em>always copies</em> types with <code>Copy</code> instead of moving them (on every assignment and passing to function)</li>
<li>No accidental implicit copies for non-<code>Copy</code> types are possible (in contrast with C++)</li>
<li><code>MyPoint</code> has only stack-allocated values inside, can't we make it <code>Copy</code> as well? Yes, we can:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Copy,Clone)]
struct MyPoint {
    x: f64,
    y: f64,
}
<span class="boring">impl MyPoint {
</span><span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">    fn is_close_to_origin(self) -&gt; bool {
</span><span class="boring">        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<h2 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow checker</a></h2>
<p>We don't actually need an independent copy of <code>MyPoint</code> on every method call. (We get now in total 3 different copies of the same value!) What we really need is only to read the value, how to do that? <em>Borrowing</em> is the way to go.</p>
<p>Borrow rules:</p>
<ul>
<li>You can access a value without owning it. You are then <em>borrowing</em> it, which basically means you have a reference (or a pointer, if we dig at lower level) to the value</li>
<li>You either:
<ul>
<li>only read the value contents (<em>immutable borrow</em>), the syntax is <code>&amp;T</code> OR</li>
<li>both read and write (<em>mutable borrow</em>), the syntax is <code>&amp;mut T</code></li>
</ul>
</li>
<li>You can have <em>multiple immutable</em> borrows OR a <em>single mutable</em> borrow (not both at the same time)
<ul>
<li>Immutable borrow means not only that you can't change the value, but nobody else can do that either!</li>
</ul>
</li>
</ul>
<p>Compiler makes sure that references are always valid:</p>
<ul>
<li>No <a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling pointers</a></li>
<li>References are never null pointers</li>
</ul>
<p>So what we need for the previous example is an immutable borrow:</p>
<pre><pre class="playground"><code class="language-rust">struct MyPoint {
    x: f64,
    y: f64,
}
impl MyPoint {
<span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span>    fn is_close_to_origin(&amp;self) -&gt; bool {
        (self.x * self.x + self.y * self.y) &lt; f64::EPSILON
    }
}

fn main() {
    let point = MyPoint::new(3., 4.);
    assert_eq!(point.is_close_to_origin(), false);
    assert_eq!(point.is_close_to_origin(), false);
}
</code></pre></pre>
<ul>
<li>Note that we've removed <code>#[derive(...)]</code> as we don't need to copy the values anymore</li>
</ul>
<p>When do we need a mutable borrow?</p>
<p>First trial:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">impl MyPoint {
</span><span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn scalePoint(point: &amp;mut MyPoint, factor: f64) {
    point.x *= factor;
    point.y *= factor;
}

fn main() {
    let mut point = MyPoint::new(3., 4.);
    let borrow1 = &amp;mut point;
    let borrow2 = &amp;mut point;
    scalePoint(borrow1, 10.);
    println!(&quot;Coordinates are: {}, {}&quot;, point.x, point.y);
    scalePoint(borrow2, 10.);
    println!(&quot;Coordinates are: {}, {}&quot;, point.x, point.y);
}
</code></pre></pre>
<ul>
<li>Code can be fixed by swapping two lines. Which ones?</li>
<li>NOTE: references have scope rules other than normal variables: the reference scope ends once the reference is <em>used</em> last (not at the end of the <code>{ ... }</code> block). It's called <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes">Non-Lexical Lifetimes (NLL)</a>.</li>
</ul>
<p>Second trial (refactoring function into a method):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct MyPoint {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span>impl MyPoint {
<span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span>    fn scale(&amp;mut self, factor: f64) {
        self.x *= factor;
        self.y *= factor;
    }
}

fn main() {
    let mut point = MyPoint::new(3., 4.);
    point.scale(10.);
    println!(&quot;Coordinates are: {}, {}&quot;, point.x, point.y);
    point.scale(10.);
    println!(&quot;Coordinates are: {}, {}&quot;, point.x, point.y);
}
</code></pre></pre>
<ul>
<li>We have two multiple borrows, but we don't violate any rules, since these two have different scopes.</li>
</ul>
<p>To get the value back from a reference, use the dereferencing syntax <code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut value = 5;
    let reference = &amp;mut value;
    *reference += 1;
}
</code></pre></pre>
<blockquote>
<h4 id="exercises-2-3-4-7-8-and-10-from-here"><a class="header" href="#exercises-2-3-4-7-8-and-10-from-here">Exercises: 2, 3, 4, 7, 8, and 10 from <a href="https://practice.rs/ownership/borrowing.html">here</a></a></h4>
</blockquote>
<h2 id="resources-for-deeper-understanding-1"><a class="header" href="#resources-for-deeper-understanding-1">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Chapter 4</a> of the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-and-generics"><a class="header" href="#traits-and-generics">Traits and generics</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<blockquote>
<h4 id="exercises-3-4-and-2-from-section-on-generics-in-rust-by-practice-yes-do-them-in-this-particular-order-and-then-ex-1-from-section-on-traits"><a class="header" href="#exercises-3-4-and-2-from-section-on-generics-in-rust-by-practice-yes-do-them-in-this-particular-order-and-then-ex-1-from-section-on-traits">Exercises: 3, 4, and 2 from <a href="https://practice.rs/generics-traits/generics.html#exercises">Section on Generics</a> in Rust By Practice (yes, do them in this particular order) and then Ex. 1 from <a href="https://practice.rs/generics-traits/traits.html#exercises">Section on Traits</a>.</a></h4>
</blockquote>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Traits:</p>
<ul>
<li>Are the Rust approach to interfaces (contracts between different parts of the code)
<ul>
<li>Traits only declare methods (not data members)</li>
</ul>
</li>
<li>Are powered by generics, though generics do not necessarily involve traits</li>
<li>Allow to write polymorphic code</li>
<li>Are good for dependency injection and mocking while testing
<ul>
<li>For example, you may emulate a hardware peripheral:</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">trait SerialPort {
    fn read_byte(&amp;self) -&gt; u8;
}

struct SerialPortMock;

impl SerialPort for SerialPortMock {
    fn read_byte(&amp;self) -&gt; u8 {
        0
    }
}

fn process_serial_input&lt;T: SerialPort&gt;(port: &amp;T) {
    println!(&quot;Serial port gives: {}&quot;, port.read_byte());
}

fn main() {
    let mock = SerialPortMock;
    process_serial_input(&amp;mock);
    process_serial_input(&amp;mock);
    process_serial_input(&amp;mock);
}
</code></pre></pre>
<ul>
<li>Single type can have (and usually does have) multiple traits, traits are easily composed
<ul>
<li>Compare this approach with the idiomatic hierarchy-based solution in pre-C++20 (multiple inheritance) which leads to the infamous <a href="https://en.wikipedia.org/wiki/Multiple_inheritance">diamond problem</a>. See more about the Rust and why it does not have the diamond problem <a href="https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/porting_from_cpp/multiple_inheritance.html">here</a>.</li>
<li>Inheritance in OOP languages involves runtime polymorphism while traits provide compile-time polymorphism</li>
</ul>
</li>
</ul>
<h2 id="traits-from-core"><a class="header" href="#traits-from-core">Traits from <code>core</code></a></h2>
<h3 id="copy-and-clone"><a class="header" href="#copy-and-clone"><code>Copy</code> and <code>Clone</code></a></h3>
<p><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>core::marker::Copy</code></a> is a trait used to implicitly copy values bit-by-bit, instead of moving the value</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>Copy</code> is an example of a <em>marker</em> trait: it does not introduce any new methods or types, it only indicates whether a certain operation is possible with the type.</li>
<li>Syntax with <code>:</code> means a <em>trait bound</em>: any type implementing <code>Copy</code> should implement <code>Clone</code> as well.</li>
<li><a href="https://doc.rust-lang.org/core/clone/trait.Clone.html"><code>core::clone::Clone</code></a> is a trait that allows <em>cloning</em> the values:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;

    fn clone_from(&amp;mut self, source: &amp;Self) { ... }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Differences between cloning and copying:
<ul>
<li>If you want to clone, you always should do this explicitly, <code>a = b.clone();</code> No implicit cloning! (In this particular case, we get two values and two owners, <code>a</code> and <code>b</code>, <em>similar</em> to copying.)</li>
<li>Cloning can be equivalent to copying, but can be totally different. On contrary, copying cannot be overriden.</li>
</ul>
</li>
<li>Good thing: you only need to implement <code>clone()</code> (it is called a &quot;required method&quot;). Once that is done, the other method (<code>clone_from()</code>) is provided automatically for you (&quot;provided method&quot;).</li>
<li>Both <code>Copy</code> and <code>Clone</code> can be automatically derived (with some default implementation), we saw that in <a href="./ownership.html">Section on Ownership</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy,Clone)]
struct MyPoint { x: f64, y: f64 }
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Some values can be neither copied nor cloned (only moved): for example for a unique resource like an open file or a hardware peripheral</li>
</ul>
<h3 id="debug"><a class="header" href="#debug"><code>Debug</code></a></h3>
<p>It's useful to dump contents of a variable, e.g. during the debugging or error logging</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyPoint {
    x: f64,
    y: f64,
}
<span class="boring">impl MyPoint {
</span><span class="boring">    fn new(x: f64, y: f64) -&gt; Self {
</span><span class="boring">        Self{x: x, y: y}
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn main() {
    let point = MyPoint::new(3., 4.);
    println!(&quot;The point is {:?}&quot;, point);
}
</code></pre></pre>
<!-- > #### Question why does the line below need `Debug`? --- we also need partialEq here,  -->
<!-- ```rust,editable -->
<!-- assert_eq!() -->
<h2 id="corefmtwrite"><a class="header" href="#corefmtwrite"><code>core::fmt::Write</code></a></h2>
<p>Documentation for <a href="https://doc.rust-lang.org/core/fmt/trait.Write.html">core::fmt::Write</a> says:</p>
<pre><code class="language-rust noplayground">trait Write {
    // Required method:
    fn write_str(&amp;mut self, s: &amp;str) -&gt; Result;

    // Provided methods:
    fn write_char(&amp;mut self, c: char) -&gt; Result { ... }
    fn write_fmt(&amp;mut self, args: Arguments&lt;'_&gt;) -&gt; Result { ... }
}
</code></pre>
<ul>
<li>This trait is normally used for unbuffered writes (like appending characters to a string)</li>
<li>Allows to use <code>println!</code>-like formatted printing</li>
</ul>
<pre><code class="language-rust noplayground">    // w implements core::fmt::Write
    // ...
    write!(w, &quot;Formatted {}&quot;, &quot;printing&quot;).unwrap();
</code></pre>
<ul>
<li>We will use this feature later for <a href="./serial.html">serial communication</a></li>
</ul>
<blockquote>
<h4 id="exercise-3"><a class="header" href="#exercise-3">Exercise</a></h4>
<p>Design a struct that implements <code>core::fmt::Write</code>, so that writing to that struct does several things simultaneously:</p>
<ul>
<li>The message contents is printed on screen</li>
<li>An internal statistical counter is updated (side effect). The counter keeps track of total number of characters being ever written</li>
<li>(*) Every second time you write to the struct, the counter value is printed on screen</li>
<li>(**) You print only whenever end-of-line is encountered in your message, but buffer the message otherwise (similar to <code>printf()</code> in C). Yes, <code>core::fmt::Write</code> is used for <em>unbuffered</em> writes, so such an implementation is not recommended for production use :-)</li>
</ul>
</blockquote>
<h2 id="resources-for-deeper-understanding-2"><a class="header" href="#resources-for-deeper-understanding-2">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Chapter 10</a> of the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>Often we have a limited number of possible values, for example on our Micro:bit we have two buttons, A and B:</p>
<pre><pre class="playground"><code class="language-rust editable">enum KeyPress {
    A,
    B,
}

fn main() {
    let key = KeyPress::B;
    match key {
        KeyPress::A =&gt; println!(&quot;Start/stop collecting the data&quot;),
        KeyPress::B =&gt; println!(&quot;Send collected data to cloud&quot;),
    }
}
</code></pre></pre>
<p>Pattern matching is exhaustive: if you forget to include an enum variant, code won't compile.</p>
<ul>
<li>Good safety feature if you add a new variant and forget to process it somewhere.</li>
</ul>
<h2 id="option"><a class="header" href="#option"><code>Option</code></a></h2>
<p>How to implement a function that either returns either some value or <em>no value at all</em>?</p>
<ul>
<li>In C and in the old-style C++, we use a null pointer for the latter case</li>
<li>In Rust, it is idiomatic to use <a href="https://doc.rust-lang.org/core/option/enum.Option.html"><code>core::option::Option</code></a>:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Two enum variants store <em>different</em> values: <code>None</code> does not store anything, <code>Some</code> stores a value of <code>T</code>.</li>
<li><code>Option</code> is similar to C++ <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>, which was introduced only in C++17.</li>
<li>For types <code>T</code> that can never be 0 (in binary representation), Rust optimizes <code>None</code> to a null pointer, so no performance loss at all!</li>
</ul>
<p><code>Option</code> has many batteries included:</p>
<ul>
<li><code>#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]</code></li>
<li>Plenty of helper functions</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: Option&lt;u8&gt; = Some(2);
    assert_eq!(x.is_some(), true);
    assert_eq!(x.unwrap(), 2);
    assert_eq!(x.expect(&quot;Oops!&quot;), 2);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: Option&lt;u8&gt; = None;
    x.expect(&quot;Oops!&quot;);
}
</code></pre></pre>
<h2 id="result"><a class="header" href="#result"><code>Result</code></a></h2>
<p>Whenever an operation may <em>fail</em>, it is idiomatic to use <a href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>core::result::Result</code></a> instead of <code>Option</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>It has a set of batteries very similar to <code>Option</code></li>
<li>If a function returns a <code>Result</code> and the caller ignores the returned value, the compiler gives a warning</li>
<li>It is very popular to use the <code>?</code> syntactic sugar to propagate errors in an elegant way:</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn problematic_function() -&gt; Result&lt;u8, ()&gt; {
    let x: Result&lt;u8, ()&gt; = Err(());
    println!(&quot;{:?}&quot;, x?);
    Ok(4)
}

fn main() {
    println!(&quot;{:?}&quot;, problematic_function());
}
</code></pre></pre>
<ul>
<li>Compare this approach with C++/Java/Python exceptions, where error propagation is <em>non-local</em> and you may easily get an exception at runtime that you were not even aware of and which crashes the application! (Or even worse, bloat the code with catching all potential exceptions in a paranoic fashion, just to be on the safe side.)</li>
</ul>
<h2 id="resources-for-deeper-understanding-3"><a class="header" href="#resources-for-deeper-understanding-3">Resources for deeper understanding</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Chapter 6</a>, <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">also here</a> and <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">here</a> in the Rust book</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-makes-embedded-rust-special"><a class="header" href="#what-makes-embedded-rust-special">What makes Embedded Rust special</a></h1>
<h2 id="embedded-vs-os-based-application-development"><a class="header" href="#embedded-vs-os-based-application-development">Embedded vs. OS-based application development</a></h2>
<p>Things that are easy to use from ordinary (non-embedded) applications:</p>
<ul>
<li>Heap allocation</li>
<li>Run a new process (you just specify the executable file, OS loads it automatically)</li>
<li>Spawn new threads and communicate between them</li>
<li>Security
<ul>
<li>You don't even notice other processes unless you really want to (or unless shared resources are over)</li>
<li>OS takes care of emergency situations like the <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow</a></li>
</ul>
</li>
<li>Read/write/create a file</li>
<li>Networking (TCP/IP)</li>
</ul>
<p>In general, it is relatively easy to write OS-agnostic code (apart from some things are not portable in principle).</p>
<p>In bare-metal embedded systems, you normally instead</p>
<ul>
<li>Avoid heap whatsoever (RAM is quite limited)</li>
<li>Make your own custom scheduler to provide multi-tasking (i.e., frequent switching between multiple tasks to make illusion of concurrent execution)
<ul>
<li>You often need a real-time response (e.g. every 1 millisecond, you need to finish processing new chunk of sensor data)</li>
<li>Data races between different tasks are easy to introduce, hard to detect</li>
</ul>
</li>
<li>Are responsible for <!-- writing your application into permanent (flash) memory and then --> initializing the RAM layout at runtime</li>
<li>Have access to all the peripherals - easy to ruin everything</li>
<li>Write/tailor drivers for the I/O (like accessing an SD card or an Ethernet controller)</li>
<li>Have to understand board-specific hardware aspects even simply to make sure your software doesn't burn the board
<ul>
<li>Logic interfacing, motor control, power supplies, etc.</li>
</ul>
</li>
</ul>
<p>There is one reward in embedded development: you have the <em>full</em> overview of your code (including all the dependencies).</p>
<ul>
<li>You design the <em>whole</em> application. Not only the userland part.</li>
<li>You can inspect any function you use, in principle. No &quot;hidden layer&quot; (like the OS kernel) beneath what you write. No external library of unknown/uncontrolled version.</li>
</ul>
<p>Anyways, embedded development sounds scary... Can Rust help here?</p>
<h2 id="embedded-rust"><a class="header" href="#embedded-rust">Embedded Rust</a></h2>
<p>Embedded Rust is different from normal Rust:</p>
<ul>
<li>You don't have access to the Rust <a href="https://doc.rust-lang.org/std/">standard library</a> (no off-the-shelf variable-size data structures and I/O).
<ul>
<li>Nevertheless all of the <a href="https://doc.rust-lang.org/core/"><code>core</code></a> (i.e., almost all that we've covered in previous Sections) is still available.</li>
<li>All the safety features of Rust are also in place.</li>
</ul>
</li>
<li>No ordinary <code>main()</code> as the default entry point <!-- : you have to do the steps preceding `main()` as well. -->
<ul>
<li>The standard <code>main()</code> expects command-line arguments as input, which don't make sense in the embedded context. And you never return from <code>main()</code> either.</li>
</ul>
</li>
<li>Panic behaviour is undefined by default: you can (and should) tailor it to your needs.</li>
</ul>
<p>You can work at 3 different abstraction layers:</p>
<ul>
<li>Peripheral-Access Crate (PAC) is the lowest layer, you access here individual MCU (MicroController Unit) registers. <a href="https://crates.io/crates/nrf52833-pac/">nrf52833-pac</a> is the PAC that we actually use under the hood for Micro:bit V2. This crate is generated automatically from an <a href="https://raw.githubusercontent.com/nrf-rs/nrf-pacs/master/svds/nrf52833.svd">XML file</a> provided by the manufacturer.
<ul>
<li>Normally you want to stay away from this layer, unless higher-level layers do no provide all the functionality you need (or maybe you need to <em>optimize</em> the existing functionality).</li>
</ul>
</li>
<li>Hardware-Abstraction Layer (HAL) is a way to abstract the <em>MCU</em> peripherals into structs and methods. We will use <a href="https://crates.io/crates/nrf52833-hal">nrf52833-hal</a>.
<ul>
<li>As an example, at this layer you can create and start a built-in hardware timer or establish a serial (UART) communication.</li>
<li>HALs in the Rust ecosystem normally build on top of the <a href="https://docs.rs/embedded-hal/"><code>embedded-hal</code></a> crate, which is basically a collection of universal traits (e.g., <a href="https://docs.rs/embedded-hal/latest/embedded_hal/digital/v2/trait.OutputPin.html"><code>digital::v2::OutputPin</code></a> for an output pin).</li>
<li>A lot of platform-agnostic drivers are written based on <code>embedded-hal</code>.</li>
</ul>
</li>
<li>Board Support Package (BSP) is the highest layer, and provides access to all the peripherals of the board (not only the ones built into MCU) like the accelerometer and the LED.</li>
<li>More explanation on different layers is <a href="https://docs.rust-embedded.org/discovery/microbit/04-meet-your-hardware/terminology.html">here</a>, together with a useful videolink.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-embedded-world"><a class="header" href="#hello-embedded-world">Hello, Embedded world!</a></h1>
<h2 id="setting-up-the-environment-1"><a class="header" href="#setting-up-the-environment-1">Setting up the environment</a></h2>
<p>Apart from the general Rust environment (including the Rust compiler and Cargo) that we have since <a href="./setting_up.html">this Section</a>, we need embedded-specific tools. Their setup on different OS platforms is described in the <a href="https://docs.rust-embedded.org/discovery/microbit/03-setup/index.html">Discovery book</a>. Make sure you look at the instructions for Micro:bit V2 (not V1)! The most important steps (apart from installing the ARM GNU toolchain and, in case of Linux, changing some permissions) are:</p>
<pre><code class="language-shell">rustup target add thumbv7em-none-eabihf
cargo install cargo-embed
</code></pre>
<h2 id="first-code-example"><a class="header" href="#first-code-example">First code example</a></h2>
<p>Get template that is tailored to our board from <a href="https://github.com/tyomaiva/first-rust-course/blob/master/microbit_template">GitHub</a>. For more details, look at the <a href="https://github.com/rust-embedded/cortex-m-quickstart">original template</a>.</p>
<p>Attach the Micro:bit using USB, go to the root of the template project, and run it:</p>
<pre><code class="language-shell">cargo embed --target thumbv7em-none-eabihf --bin hello
</code></pre>
<p>The contents of <code>src/bin/hello.rs</code>:</p>
<pre><code class="language-rust noplayground">// We don't have access to the Rust standard library
#![no_std]
// There is no standard main(), we cook it up ourselves
#![no_main]

// Implements a panic handler for us.
// The handler conveniently logs the error message to RTT
// before entering an infinite loop.
use panic_rtt_target as _;
// Enables to capture the output from Micro:bit while debugging, using the so-called
// Real-Time Transfer (RTT). Look at https://docs.rs/rtt-target/ for more details.
use rtt_target::{rprintln, rtt_init_print};
// The import is unused, but otherwise the linker
// somehow cannot find the interrupt table
use microbit::hal::prelude::*;

use cortex_m_rt::entry;

// That is the actual entry point of our program
#[entry]
// '!' means that the function never returns
fn main() -&gt; ! {
    // This should be called once (and only once) in order to set up RTT
    rtt_init_print!();
    rprintln!(&quot;Hello Embedded world, do you mind if I join?&quot;);
    loop {}
}
</code></pre>
<ul>
<li><code>cortex_m_rt</code> provides linking (based on the layout in <code>memory.x</code> file) and RAM initialization for ARM Cortex-M chips</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-microbit"><a class="header" href="#what-is-microbit">What is Micro:bit?</a></h1>
<p>The highlights of Micro:bit V2 <a href="https://github.com/microbit-foundation/microbit-v2-hardware/blob/main/V2.00/MicroBit_V2.0.0_S_schematic.PDF">schematics</a>:
<img src="images/mcu_connections.png" alt="MCU connections" />
<img src="images/led_matrix.png" alt="LEDs" /></p>
<p>The NRF52833 functional diagram from <a href="https://infocenter.nordicsemi.com/index.jsp?topic=%2Fstruct_nrf52%2Fstruct%2Fnrf52833.html&amp;cp=3_1">the manufacturer</a>:
<img src="images/NRF52833_diagram.png" alt="MCU" /></p>
<ul>
<li>The heart of the MCU is an ARM Cortex-M4 CPU core
<ul>
<li>That is where our Rust code executes</li>
<li><code>thumbv7em-none-eabihf</code> Rust target basically tells what machine code to emit (e.g., we have 32-bit CPU registers and an FPU for fast floating-point calculations)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-led-matrix"><a class="header" href="#the-led-matrix">The LED matrix</a></h1>
<p>Now it's time to control some of the board peripherals, we start with the 5x5 LED matrix. The new things that we need compared to the <a href="./hello_embedded_world.html">&quot;Hello World&quot; example</a> are</p>
<pre><code class="language-rust noplayground">// Add your code here ...
use microbit::{
    board::Board,
    display::blocking::Display,
    hal::Timer,
};
// Add your code here ...
#[entry]
fn main() -&gt; ! {
// Add your code here ...
    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);
//  Add your code here ...
}
</code></pre>
<ul>
<li><code>board</code> is a struct with all the peripherals we have, see <a href="https://docs.rs/microbit-v2/latest/microbit/board/struct.Board.html">here</a>
<ul>
<li><code>TIMER0</code> is one of the 5 hardware timers available on the board</li>
<li><code>display_pins</code> are the 10 GPIO pins that control the LED matrix
<ul>
<li>(*) How can 5 * 5 = 25 LEDs be controlled by only 10 pins?</li>
</ul>
</li>
</ul>
</li>
<li>You can use methods <code>show()</code> and <code>clear()</code> of the struct <a href="https://docs.rs/microbit-v2/latest/microbit/display/blocking/struct.Display.html"><code>microbit::display::blocking::Display</code></a> to manipulate the LED state.</li>
<li>To introduce time delays (&quot;sleeps&quot;), the method <code>delay_ms()</code> is available for <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Timer.html"><code>microbit::hal::Timer</code></a>.</li>
</ul>
<blockquote>
<h4 id="exercise-4"><a class="header" href="#exercise-4">Exercise</a></h4>
<ul>
<li>Make the matrix to light a pattern (e.g., all LEDs are on) for 1 second, then switch to another pattern (e.g., all LEDs are off) for another second, and repeat this switching indefinitely.</li>
<li>(*) Make a dice: every second, light up one of 6 dice patterns, either in a deterministic fashion (e.g., first you show 1, then 2, and so on) or randomly
<ul>
<li>You can either use <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Rng.html"><code>microbit::hal::Rng</code></a> as a proper method for generating random numbers, or use instead <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Timer.html#method.read"><code>hal::Timer::read()</code></a> as a hack.</li>
</ul>
</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serial-communication-with-uart"><a class="header" href="#serial-communication-with-uart">Serial communication with UART</a></h1>
<p>Universal Asynchronous Receiver-Transmitter (UART)</p>
<ul>
<li>Is a serial-communication protocol (data is sent serially, usually byte-by-byte)</li>
<li>Full duplex (reception and transmission do not interfere with each other)</li>
<li>More details are <a href="https://docs.rust-embedded.org/discovery/microbit/06-serial-communication/index.html">here</a></li>
</ul>
<p>Code for Micro:bit:</p>
<pre><code class="language-rust noplayground">use microbit::hal::uarte;

// Add your code here ...

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = uarte::Uarte::new(
        board.UARTE0,
        board.uart.into(),
        uarte::Parity::EXCLUDED,
        uarte::Baudrate::BAUD115200,
    );

    display_message(&amp;mut serial, &quot;Hello, do you see me?&quot;);

// Add your code here ...
}
</code></pre>
<p>Apart from Micro:bit, we need to send and receive messages on the <em>host computer</em> somehow. One way is to use a standard tool (PuTTY on Windows, minicom on Linux), but it's more fun to use more Rust and less external applications. So, take code from <a href="https://github.com/tyomaiva/first-rust-course/blob/master/serial_port_processing">GitHub</a> and run it in a separate window using <code>cargo run</code>. (Make sure to run it a couple of seconds earlier than the Micro:bit application, in order to capture the incoming message.)</p>
<p><a href="https://docs.rs/microbit-v2/latest/microbit/hal/uarte/struct.Uarte.html"><code>microbit::hal::uarte::Uarte</code></a> implements</p>
<ul>
<li><code>read()</code> and <code>write()</code> methods, which receive and send serial messages, respectively</li>
<li><code>core::fmt::Write</code> trait (see <a href="./traits_generics.html">Section</a>)</li>
</ul>
<blockquote>
<h4 id="exercise-5"><a class="header" href="#exercise-5">Exercise</a></h4>
<ul>
<li>Implement a standalone function <code>display_message()</code> that receives instance of <code>Uarte</code> and a message string (more precisely, a string slice, <code>&amp;str</code>) and does two things at the same time:
<ul>
<li>Sends the message via <code>Uarte</code></li>
<li>Prints the message using <code>rprintln!</code></li>
</ul>
</li>
<li>Make <code>display_message()</code> generic over any type that implements <code>core::fmt::Write</code> so that mocking of the UART peripheral becomes possible, in principle</li>
<li>Echo the incoming messages back in an infinite loop using <code>display_message()</code>
<ul>
<li>Hint: use <a href="https://doc.rust-lang.org/beta/core/str/fn.from_utf8.html"><code>core::str::from_utf8()</code></a> to convert result of <code>read()</code> to <code>&amp;str</code></li>
</ul>
</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="putting-all-together-streaming-data-from-the-accelerometer"><a class="header" href="#putting-all-together-streaming-data-from-the-accelerometer">Putting all together: streaming data from the accelerometer</a></h1>
<p>Micro:bit has a built-in accelerometer that can communicate with the CPU using I\(^2\)C protocol, see <a href="https://crates.io/crates/lsm303agr">this crate</a></p>
<blockquote>
<h4 id="exercise-6"><a class="header" href="#exercise-6">Exercise</a></h4>
<p>Design an application that reads accelerometer values for X-, Y-, and Z-accelerations every 0.5 second and sends them to your PC using UART.</p>
<ul>
<li>Test it by shaking the board and observing the changes in resulting readings.</li>
</ul>
</blockquote>
<p>Useful code fragments:</p>
<pre><code class="language-rust noplayground">// TWIM is the same as I2C master, different name is used for legal reasons
use microbit::hal::twim;
use microbit::twim0::frequency::FREQUENCY_A;

// ...
let board = microbit::Board::take().unwrap();
let mut i2c = twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
let mut sensor = Lsm303agr::new_with_i2c(i2c);
sensor.init().unwrap();
// ...
</code></pre>
<p>Useful methods:</p>
<ul>
<li><a href="https://docs.rs/lsm303agr/0.2.2/lsm303agr/struct.Lsm303agr.html#method.set_accel_odr"><code>set_accel_odr()</code></a></li>
<li><a href="https://docs.rs/lsm303agr/0.2.2/lsm303agr/struct.Lsm303agr.html#method.accel_status"><code>accel_status()</code></a></li>
<li><a href="https://docs.rs/lsm303agr/0.2.2/lsm303agr/struct.Lsm303agr.html#method.accel_data"><code>accel_data()</code></a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
